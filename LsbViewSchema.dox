////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\mainpage Leave Script Behind Explained

This is the documentation for the Leave Script Behind (aka LSB) application. It includes introduction on how to use the LSB application, explanation of schema for LSB view files, steps on creating new LSB views, instructions on debugging and publishing LSB view files, as well as answers for other questions.

- \ref section_intro
- Using LSB
  - \ref section_ui
  - \ref section_settings
  - \ref section_views
  - \ref section_wrapper_script
- Using LSB in a better way
  - \ref section_smart_time
  - \ref section_smart_filter
- Schema - this section explains the schema for the LSB view files,
  - \ref section_enum
  - \ref section_data
  - \ref section_view
  - LsbView
- Create your own LSB view
  - \ref section_create_view
  - \ref section_debug_view
- \ref section_faq
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_intro Introduction

# Welcome to the Leave Script Behind!

Leave Script Behind (aka LSB) is a tool developed for developers, more specifically, DevOps.

Since from the invention of the Internet, more and more services are moved to the online world. This implies that more and more developers are now working in the DevOps mode to make their products/features released fast and safe. To achieve that, they inevitably need to work with shells and command line tools in their daily work, from service deployment to live site investigation and mitigation. Depends on which operating systems they are using, they may need to interact with different types of shells in the command line form (CLI), such as **PowerShell** on **Windows**, __GNU bash__ on **Linux**, and __zsh__ on **Mac %OS X**, etc.

The shells are known as providing capabilities to allow user to run commands/programs on operating systems, and allow users to create scripts to chain commands as needed to complete complicated tasks, and then repeat the same work later by simply run the script solely. Along with the strong flexibility and great power come with the shells and scripts, there is also a steep learning curve for new users to master all the knowledge needed to achieve what they want to do, from learning the different commands available in the shell(s), to grasping the usage of each command, including various parameters, unique parameter values, combinations of the parameters and values, as well as how to chain the commands and write corresponding shell scripts in correct syntax and logic. Besides, both the shell input and output are usually presented in plain text in the shell console, which means that users must have knowledge beforehand to understand the constraint output in plain text. There is no way for user to interact with the result data after it's already outputted in the shell console, unless user re-runs the command and stores the result into a variable in the shell supported way, then user may manipulate the variable to digest more from it.

LSB is a cross-platform tool designed with the goal to reduce the pain decribed above - it chains multiple sequences of shell scripts and commands to complete a complicated task, allows user to interact with data in the middle through GUI, provides a way to store and reuse the same processes (named LSB views) later for the same tasks. Depends on how a view is designed, it can display the data output from command(s) at each step in a manipulatable way, user can interact with the data to create the input for the next step (the next sequence of commands), and so on, step by step, till the workflow reaches its end state and user completes the task. By reusing the LSB views, it can greatly ease the user's work by avoiding remembering all the shell commands needed, their parameters, and the error-prone parameter combinations, as well as repetitively executing same commands again and again. Each LSB view provides funtionality similiar to a script file but offers much richer capabilities,
- Data visualizaion through various view controls like list view, tree view, chart view and many others, instead of very limited plain text form.
- Interaction with the intermediate data, users may select different entries in the intermediate data to continue the workflow with different logic and actions.
- Multiple input controls available for users to input values in various data types, from integer, string, to files, etc. It provides the PropertyInput control to support multiple parameter input in one single control.
- Layout capability to arrange the input controls and data view controls through simple XML configuration.
- Embedded support for data connectivity to SQL databases, Web APIs, etc. with configuration defined in the view file. This feature will be available soon in next release.
- Lua language intergation in LSB for dataset creation, data processing and task execution.
- Extensibility to support any shell type that the host operating system supports. LSB can run any shell scripts to implement desired functionalities as long as the shell support is configured properly.
- Ability to mix multiple script snippets in the same type or different types (e.g., Lua, PowerShell, bash, zsh) in the same view to complete complicated tasks.

By providing these capabilities, the LSB can help to address the user's following pain points,
- For end users, it reduces their effort needed to learn various script languages and commands. They only need to learn how to use the LSB views to complete tasks, without needing to know the underlying commands and scripts, as the GUI views are more intuitive than their command line counterparts.
- For developers, the LSB views can be implemented using their preferred shells/languages, and they can also mix different shells within a single LSB view to create the most effective workflow for them.
- It significantly enhances the experience on how the end users can interact with the intermediate data generated from a set of commands,
  - Allow users to view the data in well-organized formats like list view, tree view, etc.
  - Enable data visualization in various graph types, including but not limited to bar charts, pie charts, histograms, and heat maps, etc.
  - Allow users to select data entries (using mouse) as input for subsequent workflow steps.
- The Lua language embedded within LSB ensures cross-platform compatibility. By utilizing Lua scripts only within a LSB view, the view can operate seamlessly across all platforms, including Windows, Linux, and Mac OS X.
- Uploading an LSB view to the LSB repository makes it accessible to all LSB users, allowing any user to reuse the views created by others effortlessly. This is also an easy way for the view developers to pushlish their work, and get acknowledged by other developers and users.
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_ui The LSB UI

The LSB application features a multiple window multiple document interface (MDI). It launches with the main window only, which contains the menu bar and the toolbar. When user opens a LSB view file through menu item or toolbar button, the opened LSB view appears in its own separate window. If the user opens the same view file again, a new window is created for that new instance of the LSB view. Regardless of whether the LSB view file is the same or different, each view instance always has its own dedicated window.

## 1. Main window

Here's the main window of the LSB application,

\image html lsb-main-window.png

### 1.1 Menu

#### 1.1.1 The **File** menu

\image html lsb-menu-file.png

<ul>
<li>**Open view ...** - This menu item launches the **"Open a view"** dialog for user to select a view file from LSB view list and open as LSB view.</li>
<li>**Open recent view** - This is a sub-menu - each item in the sub-menu stands for an LSB view previously opened. Select an item in the sub-menu will open that previously opened LSB view directly.</li>
<li>**Close all views** - Selecting this menu item will close all the currently opened LSB views.</li>
<li>**Manage view history ...** - This menu item launches the **"Manage opened view history"** dialog to configure how the previously opened LSB view files are ordered in the **"Open recent view"** sub-menu.</li>
<li>**Exit** - This menu item closes all the opened LSB view windows and exits the LSB application.</li>
</ul>

#### 1.1.2 The **Windows** menu

\image html lsb-menu-windows.png

<ul>
<li>**Views** - This is also a sub-menu. It contains a list of all currently opened LSB views. Selecting an item in the sub-menu will bring the corresponding LSB view into front and make it the active view.</li>
<li>**Global log window** - This is a toggle menu item. It controls the visibility of the **"Global logging"** window. If the **"Global logging"** window is not visible, selecting this item will show the **"Global logging"** window and bring it into front. Otherwise, if the **"Global logging"** window is already visible, then selecting this menu item will hide it, not close it. The **"Global logging"** window logs the view open/close events and all the other application level events.</li>
</ul>

#### 1.1.3 The **Option** menu

\image html lsb-menu-option.png

<ul>
<li>**Settings ...** - Currently this is the only menu item in the **"Option"** menu. It launches the LSB **"Settings"** dialog for user to change the various configurations for the LSB application, from the **"General"** settings to **"Shells"** configurations and **"Views"** repository configurations.</li>
</ul>

#### 1.1.4 The **Help** menu

\image html lsb-menu-help.png

<ul>
<li>**Help ...** - This menu item shows the **"LSB Help"** window with the help content for the LSB application, including the page you are reading now.</li>
<li>**%About ...** - This menu item shows the **"About LSB"** dialog which contains the information about the LSB application, including the credits to the SDK libraries and other resources used for the LSB development.</li>
</ul>

### 1.2 Toolbar Buttons

In the main window, there is a toolbar that contains a set of buttons for quick access to certain functionalities. The funtionalities provided by these buttons are also available through the menu items in the main menu.

\image html lsb-main-window.png

<ul>
<li>**Open view** - This button has the same functionality as the **"Open view ..."** menu item under the **"File"** menu. Clicking on the button will launch the **"Open a view"** dialog to select and open an LSB view. Besides, the little triangle next to the button triggers a drop-down menu that shows the same view history as the **"Open recent view"** sub-menu does. Selecting an item in the drop-down menu will open the corresponding LSB view file directly.</li>
<li>**Close all views** - This button is same as the **"Close all views"** menu item under the **"File"** menu, it closes all currently opened LSB views.</li>
<li>**Manage history** - This is another entry to launch the **"Manage opened view history"** dialog for manipulating how the items in the **Open recent view** sub-menu are ordered.</li>
<li>**View** - This button is only enabled if there is at least one LSB view opened. It will launch the **"Select view"** dialog for user to select a view from a view list which contains all currently opened LSB views and make the selected view active. There is also a button with little triangle next to it which triggers a drop-down menu that contains menu items mapped to all currently opened LSB views. Select a menu item there will bring the corresponding opened LSB view into front and make it active.</li>
<li>**Log window** - This button toggles the **"Global logging"** window. When the **"Global logging"** window is invisible, clicking on the button will show the window and bring it into front.</li>
<li>**Settings** - This button launches the **"Settings"** dialog for user to make changes in the configuration for the LSB application.</li>
<li>**Help page** - This button shows the **"LSB Help"** window with the help content for the LSB application.</li>
<li>**%About LSB** - This button shows the **"About LSB"** dialog with the about information for the LSB application.</li>

## 2. LSB View window

An LSB view window typically consists of at least four pages, **View**, **Logs**, **Lua** and **%About**.

### 2.1 View page

The **View** page displays content that is created based on the configurations in the LSB view file. Various controls, such as input controls and data view controls, are arranged using different layout controls inside a view. In this screenshot from the "Chart view sample," the root control is a TabLayout layout control, which consists of four tabs, "Bar Column", "Data in range", "Pie / Doughnut / Bubble", and "Scatter / Line / Area". Each tab utilizes a TableLayout control to organize four ChartView controls into a 2x2 table, presenting different types of charts respectively.

\image html lsb-view-view.png

### 2.2 Logs page

The **Logs** page captures local logging, detailing all events raised within the LSB view instance. For example, each view control inside an LSB view performs a condition check (defaulting to empty code though, meaning the condition always returns a true value) to determine if the data source for the view control should be accessed/evaluated and the content of the view control should be updated. The results of these condition checks are logged in the message list in the top. When an output parameter value changes in one view control and then subsequently triggers an input parameter value change in another view control, both events are recorded in the parameter change list in the bottom. This feature can assist the view creators in debugging by verifying whether the correct parameter values are sent out from a view control (through output parameters) and properly transmitted to target view controls(through input parameters).

\image html lsb-view-logs.png

### 2.3 Lua page

The **Lua** page contains Lua code snippets executed within the LSB view instance. Even if no explicit Lua script is used in an LSB view, this page remains there due to implicit functions implemented in Lua in each LSB view. These Lua scripts run from view loading to parameter checking. For instance, it automatically creates an `lsb` object (a table in Lua) in the Lua runspace to share the view path, file, and name, etc. with other Lua code in the view. The check conditions for each view control support Lua language only. The content in this page is read-only and displays the executed Lua code with syntax highlighting.

\image html lsb-view-lua.png

### 2.4 About page

The **%About** page displays information about the LSB view. The content on this page is configurable within the LSB view file. It can be generated from the view file itself or linked directly to a web page available on the Internet.

\image html lsb-view-about.png

### 2.5 Other pages

If the view author uses shells like PowerShell, Bash, or Zsh to implement functionalities for the LSB view, new pages will be added for each type of shells used respectively. This per shell page displays the executed shell scripts along with their outputs. Both the view author and end users can use this page to review the executed shell commands and their generated outputs, to ensure the view content is updated as expected.

## 3. Dialogs
There are a number dialogs employeed in the LSB application to display data and update configurations for the application.

### 3.1 Open a view dialog

The **Open a view** dialog helps user to find, select, and open an LSB view file with the LSB application. It consists of a view list and a preview pane. It automatically searches all configured view repositories to find LSB view files and adds them into the view list. When user selects an LSB view from the view list, the view information is displayed in the preview pane. The view list supports smart filter, see \ref section_smart_filter for more information. The smart filter enables user to quickly locate a view through combination of column based filters. When an LSB view is selected, user may also click on the **"Open the view folder"** button to open the folder that contains the view file using the %OS native file management application, such as the **File Explorer** on Windows, the **Finder** application on Mac %OS X, etc.

\image html lsb-open-view.png

### 3.2 Manage opened view history

This is the dialog that manages how the view history is displayed in the **"Open recent view"** sub-menu under the **"File"** menu.

\image html lsb-manage-history.png

<ul>
<li>**History count settings**
  <ul>
    <li>**Maximum item count in menu** - This setting controls how many items will be displayed in the **"Open recent view"** sub-menu under the **"File"** menu. The value should be within the range [1, 9] inclusive, and should be less than the value of **Maximum item count in history file**.</li>
    <li>**Maximum item count in history file** - This setting controls how many items will have the opened history data stored in the history data file. The value should be within the range [1, 99] inclusive, and should be larger than the value of **Maximum item count in menu**.</li>
  </ul>
</li>
<li>**How are the view files ordered**
  <ul>
    <li>**Most recently used time** - When this option is selected, the view files are ordered by most recently used time.</li>
    <li>**How many times view used** - When this option is selected, the view files are ordered by how many times the view file is opened.</li>
  </ul>
</li>
<li>**View file history** - This is a list of view files opened previously. They are ordered based on the option selected above - by most recently used time or by how many times view used.</li>
</ul>

### 3.3 Select view

This dialog is launched when user clicks on the **View** button in the toolbar in the main window. It shows the full list of currently opened LSB views. If user selects a view from the list and then clicks the **OK** button, the selected view will be brought into front and become an active view.

\image html lsb-view-list.png

### 3.4 Settings

The LSB **"Settings"** dialog is explained in the next section \ref section_settings.

*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_settings The LSB Settings

The LSB settings dialog allows user to configure various aspects of the LSB application. The settings are organized into four categories: **General**, **Colors & Fonts**, **Shells**, and **Views**. Please refer to the following sections to learn more about each setting and understand how they affect the behavior of the LSB application.

## General category

This is the general setting category for the LSB application. The settings included in this category are,

\image html lsb-settings-general.png

**TODO: update the screenshot for the general settings**

<ul>
<li>**Aggregation time window for multiple input parameter changes** - This defines the length of a time window in milliseconds. For an LSB view control, there might be multiple input parameters defined on it, and some of these parameters could have their values changed simultaneously (or within a very short time frame). If this time window length is set to 0 millisecond, every parameter value change will trigger data load and content refresh for the view control, which is usually not the expected behavior, they should be consolidated into one data load and content refresh. By setting this time window to a short duration, all parameter value changes occurred within this time window will be recognized as one change, and will be triggering one single data load and content refresh. Please note that this time window is a moving window. For instance, if the time window length is set to `D` and the first input parameter value change happens at `T0`, and a second parameter change happens at `T1` (where `T1 - T0 <= D`), then these two input parameter changes will be recognized as one action, and the actual data load/content refresh will be triggered at `T1 + D`. If there is a third parameter value changes at `T2` where `T2 - T1 <= D`, then the data load/content refresh will be deferred again to `T2 + D`, until no parameter value change happens within the `D` duration after the last parameter value change. In general, if `n` parameters have their values changed around the same time (with the time gap between each adjacent two parameters being less than `D`), the actual data load/content refresh will happen at `Tn + D`.
<li>**Default view size** - This setting defines the default window size for an LSB view. When a LSB view is opened, it will be set to this size by initially.</li>
<li>**Select the icon theme for the application** - This setting controls the icon theme for the LSB applciation. It provides all available icon themes in a list and user may select one of them to be the theme for the application. Please be reminded that after a new icon theme is selected, it requires a restart of the LSB application to take effort. Currently the default theme is the smashicons theme.
<li>**Show the GIT client window during execution for enlistment or refresh** - The LSB application uses GIT to synchronize the default view repository, the help document repository, as well as other user configured view repositories. It calls the `git` command to get the files synced. This setting controls if a console window is shown during the synchronization.</li>
<li>**Enable proxy server for Web requests at port** - This is an experimental feature. The LSB application has implemented a proxy server to help to route requests from WebView with local content (which typically has origin set to null) to a remote Web endpoint to address the CORS issue. Without the proxy server, the local pages won't be able to see the response from the remote Web endpoint unless the Web server has configures to accept CORS requests, which is not true in most cases.</li>
</ul>

## Color & Fonts category

This category contains the color and font settings for LSB.

\image html lsb-settings-ui.png

<ul>
<li>**Active view caption** - These settings allow user to configure the colors and font for the caption of active view controls. Users can click on the foreground or background colors to change them, and click on the "Choose..." button to select the font for the active view control. The Preview control will display the final effect of any changes made to these settings.</li>
<li>**Inactive view caption** - These settings allow user to configure the colors and font for the caption for the inactive view controls. Users can click on the foreground and background colors to change them, and click on the "Choose..." button to select the font for the inactive view control. The Preview control will displau the final effect of any changes made to these settings.</li>
<li>**Shell window content** - This is the setting for the shell window content. When a shell window is displayed, such as the GIT console window for the view synchronization, it will be displayed with the colors and font configured here. Changes on these settings are displayed in the Preview pane immediately after a change is made.</li>
</ul>

## Shells category

This category allows the user to configure the shells supported in LSB views. This page consists of a shell list and a set of tool buttons that help to manage the shell list.

\image html lsb-settings-shells.png

<ul>
<li>**Scan** - This button is used to scan all shells available in the host Operating System. The found shells will be added into the shell list automatically with default settings.</li>
<li>**Edit** - This button is enabled only if an item in the shell list is selected. Clicking on the button will open the shell setting editor dialog to update the settings for the selected shell. See the **"Edit settings for xxx"** section below on how to customize the settings for a shell.</li>
<li>**Add** - This button adds a new shell into the shell list by launching the shell setting editor dialog with empty settings for the new shell to be added.</li>
<li>**Delete** - This button deletes the currently selected shell from the shell list. It's only enabled if a shell item is selected in the shell list.</li>
<li>**Clear** - This button removes all shells from the shell list.</li>
</ul>

**Note:** Double click on an item in the shell list has the same effect as clicking the **Edit** button - it launches the shell setting editor dialog for updating the shell settings.

### Edit settings for xxx

This is the dialog used for creating and editing the settings for a shell to be used within the LSB application. The LSB views can execute shell scripts only if the corresponding shell setting exists, which is typically created using this dialog.

\image html lsb-shell-editor.png

Here are the settings user can set for a shell,
<ul>
<li>**Name** - Name of the shell. This value will be used as the shell type in the shell scripts embedded in the LSB views.</li>
<li>**Path** - This is the absolute path to the shell executable.</li>
<li>**Reference / Module list** - This is basically a list of shell script files. These script files will be automatically loaded into the corresponding shell when the shell process is created, the scripts in these files will be executed before any other scripts defined in the LSB view files. Thus the shell scripts defined in the LSB view file can use the variables and functions defined in these references or modules.</li>
<li>**Placeholders** - These are placeholders to be used in the script wrapper. These placeholders will be replaced by actual values before script execution. They are used to help on the execution of the user specified script in the shell process, and collect data back to the LSB application.
  <ul>
    <li>**Customized user script** - This is the placeholder for the shell script defined in the LSB view file.</li>
    <li>**Intermediate data file** - This is the placeholder for the full path of an intermediate data file to store the data output from the user scripts defined in the LSB view file. The LSB application will try to load the script generated data from this intermediate data file and use the data in the LSB view.</li>
    <li>**First half of signature** - This placeholder is for the first half of a randomly generated signature data. See the section \ref section_wrapper_script to understand how these signature is used in the shell script execution.</li>
    <li>**Second half of signature** - This is placeholder for the second half of the randomly generated signature data. It's used together with the first half of signature data to form the complete signature. See \ref section_wrapper_script for more details.</li>
    <li>**Path to view file** - This is the placeholder for the full path to the currently opened LSB view file.</li>
  </ul>
</li>
<li>**User script wrapper** - This is a piece of shell script that wraps the user-defined script in an LSB view to be executed in the shell process. The wrapper script transfers the output data generated from the user-defined script into an intermediate data file, generating and outputting signature data to the shell console to notify the completion of the script execution. It can also have any other helper functions added to assist the user-defined script execution.</li>
<li>**Script execution timeout** - This is the default timeout setting for the user-defined script execution. Each piece of user-defined script could have its own customized timeout set through the script data source configuration in the LSB view file, see ScriptData. If it's not configured there in the LSB view file along with the user-defined script, then this default timeout setting is used.</li>
</ul>

## Views category

This category allows users to configure the view repositories used in LSB. This page consists of a view repository list and a set of tool buttons that help to manage the view repository list.

\image html lsb-settings-views.png

<ul>
<li>**Edit** - This button is enabled only if an LSB view repository is selected in the repository list. Clicking on the button will open the **"Edit view repository settings for xxx"** dialog to update the settings for the LSB view repository. See section below for the details of how to customize the settings for an LSB view repository.</li>
<li>**Synchronize** - If the currently selected LSB view repository is a GIT repository and the remote GIT repository URL is provided, this button is enabled. Clicking on the button will trigger the synchronization of the view files from the remote GIT repository to the local enlistment.</li>
<li>**Add** - This button is to add a new LSB view repository into the repository list. It launches the **"Edit view repository settings for xxx"** dialog with empty settings for the new LSB view repository.</li>
<li>**Delete** - This button deletes the currently selected LSB view repository from the repository list. The button is enabled only if an LSB view repository is selected in the view repository list. </li>
<li>**Clear** - This button removes all LSB view repositories from the repository list.</li>
</ul>

### Edit view repository settings for xxx

When user requests to add a new LSB view repository or edit an existing view repository, this editor dialog is launched for customizing the settings for the LSB view repository.

\image html lsb-view-repository-editor.png

<ul>
<li>**Name** - Name of the LSB view repository. The value will be shown in the Repository column in the view list in the **"Open a view"** dialog.</li>
<li>**Local view root** - This is the local path to the root folder of the view repository.</li>
<li>**GIT repository URL** - If a view repository is synchronized from a remote GIT repository, this is the GIT repository URL. If it's empty, then the view repository becomes a local repository, no synchronization will be executed for it.</li>
<li>**Refresh interval** - This setting is only applicable if the LSB view repository is synchronized from a remote GIT repository. It controls the frequency of synchronization between the LSB local enlistment and the remote GIT repository. The automatic synchronization only occurs during the launch of the LSB application. Additionally, manual synchronization by clicking the **Synchronize** button in the **Views** configuration page does not adhere to this interval setting; it performs the synchronization immediately when the button is clicked.</li>
<li>**The repository is enabled to use the views hosted in it** - This is a switch that controls if the LSB views in this view repository should be listed in the **"Open a view"** dialog. When this setting is unchecked, though the view files belong to this view repository sit in the local folder on the user's machine, the LSB view files won't be visible in the view list in the **"Open a view"** dialog.</li>
</ul>

*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_views The LSB View Repositories

The LSB views are managed through view repositories, either locally or remotely. In each of the LSB view repositories, the views can be futher categorized through folders (and sub-folders). The LSB application will recursively find all the view files under the root folder of an LSB view repository and show them in view list in the **"Open a view"** dialog. There could be multiple views with the same name in the same view repository, as long as they are put in different folders, they can co-exist.

## Default View Repository

The LSB applciation comes with a default view repository that is a GIT repository and available at https://github.com/xjluo-lsb/lsb.views. When the LSB application is launched, if the default view repository is not available, the LSB application will automatically clone the GIT repository and make the views available to user. This view repository will be named as DefaultViews. This view repository is configured automatically and it's not changeable through the view repository configuration page in the **"Settings"** dialog.

## User Configured View Repositories

Users can configure their own repositories in LSB. As described in the **"View category"** in the **"Settings"** dialog, users can configure a local-only repository by pointing the local view root to a local folder and leaving the GIT repository URL empty. In this case, all views from this repository are available locally and not shared with others.

Users can also configure a remote view repository by providing both the GIT repository URL and the local view root folder. In this case, all LSB views in the GIT repository will be automatically synchronized to the local folder each time the LSB application is launched. This allows users to easily reuse LSB views created by others or share their own views with others.

For the community version of the LSB application, users can use the default view repository that synchronizes from the default official repository hosted on GitHub. Additionally, users can add one local repository for creating and managing their own LSB views. However, adding a remote repository or adding more than one local repository is not allowed. For the paid version, there is no limitation on the repository count. Users can add as many repositories as they want, either local or remote, and all the remote repositories will be all automatically synced during the launch of the LSB application.

In the view repository setting, user may also temporarily enable/disable a view repository by check/uncheck **"The repository is enabled to use the views hosted in it"**. When there are too many views available through multiple view repositories, this might be helpful to shorten the view list in the **"Open a view"** dialog.

## Sample Views

In the DefaultViews view repository, the LSB application already provides a set of sample views under the samples folder. These views are used to demonstrate what view controls are available in LSB, what a LSB view can do, how parameter values are passed around, etc. They are good samples for learning how to create your own LSB view. Here are a few examples from them,

### all-controls-demo.lsbv
This view demostrates majority of the controls supported in the LSB. It requires pwsh (PowerShell or PowerShell 7+) to be configured to run the scripts and demostrates following features,
<ul>
<li>Using Lua scripts defined in script reference, using PowerShell scripts defined in script reference.</li>
<li>Using PowerShell script for generating setting data for the PropertyInput control, which overrides the property definitions configured in the view file.</li>
<li>String input in the PropertyInput is sent to the ListView control for updating the caption for the ListView.</li>
<li>Demonstrates the context menu in the ListView.</li>
<li>Uses external Web site page (the wxWidgets home page) as the about page.</li>
<li>Data controls used in the view: ListView / TextView / TreeView / ChartView / TreeListView / WebView</li>
<li>Input controls used in the view: TextInput / ComboBox / PropertyInput / ButtonGroup</li>
<li>Layout controls used in the view: SplitLayout / TableLayout / TabLayout</li>
</ul>

### file-explorer.lsbv
This view illustrates the FileTree and FileList controls provided in LSB to compose a view with functionalities similar to the file managers (such as Windows Explorer on Windows, Finder on Mac OS X, GNOME Files on Fedora, etc).

Besides, this view also demonstrates the context menu configuration on the FileList control and how to call into function `lsb.showMessage()` in the Lua script to show message from the context menu. Double click on a plain text files listed in the FileList control will trigger the view to show the content in the TextView control.

This view uses Lua scripts only for the functionality implementation, thus it supports all operating systems.

### Graphs and Charts
There are 3 graph and chart sample views available, using different frameworks to draw the graphs and charts.
<ul>
<li>**chartjs-sample.lsbv** - This view uses the Chart.js library inside WebView control to visualize data. Credit to the contributors of the Chart.js library. Please visit https://www.chartjs.org/ to find more details about the library.</li>
<li>**d3-sample.lsbv** - This is another view uses the WebView control to render the graphs, while it uses the well-known D3 library (https://d3js.org/) to visualize the data. It contains three examples copied and modified from the original D3 samples. The Scatterplot is based on https://observablehq.com/@d3/scatterplot-tour, the Disjoint force-directed graph is based on https://observablehq.com/@d3/disjoint-force-directed-graph/2 and the Zoomable circle packing comes from https://observablehq.com/@d3/zoomable-circle-packing.</li>
<li>**chartview-sample.lsbv** - This sample view mainly demonstrates the ChartView in the LSB. It shows examples for all the chart types supported by ChartView, including Bar chart, Stacked bar chart, Column chart, Stacked column chart, Candlestick chart, Box plot, OHLC chart, Histogram, Pie chart, Polar area chart, Doughnut chart, Bubble chart, Scatter plot, Line chart, Math2D plot and Area chart. The data used in these charts are generated from Lua script that is defined in the script reference in the view. The ChartView control is built on top the wxCharts library. Credit to the authors of the wxCharts library, see more details at https://github.com/wxIshiko/wxCharts.</li>
</ul>

### hexview.lsbv
This view illustrates how the HexView control provided by LSB can be used to display data or file in the hexadecimal form. It can open any file to be displayed in hexadecimal. This view demonstrates two different ways to load the file content into the HexView control,
<ul>
<li>Load file in Lua code, convert the content into hexadecimal string and send to the HexView control. This way can be used for displaying any data as long as the data is preprocessed to be hexadecimal string.</li>
<li>Send the file path to the HexView control and load the content directly in HexView.</li>
</ul>

There are already many example views available in the default view repository. Along with the time, more and more views will be added into this view repository. Please feel free to explore and play these views to learn what they can do as well as using them as sample to learn how to create your own LSB views.
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_wrapper_script The Wrapper Script for Shells

In the shell settings, there is a script wrapper used for connecting the user-defined script with the LSB view. It contains several placeholders that will be replaced by real values before execution. The user-defined script is not sent to the shell process directly. Instead, the script wrapper with all placeholders substituted with real values, which includes the user-defined script, is the final script that will be sent to shell process to execute, and then the response from the script will be collected from the intermediate data file (if it's created during the final script execution) or the script output will be used for the response content (if the intermediate data file is not used).

The placeholders serve for different purpose during the shell script execution. The LSB application relies on them to get the script executed properly and have the responses collected and shared with other view controls in the same LSB view.
<ul>
  <li>**Customized user script** - **[Mandatory]** this placeholder is used for including the user-defined script in the LSB view. Assuming the placeholder for the user-defined script is `%%USER_SCRIPT%%`, if user wants to send the scripts defined in an LSB view directly to the shell process, user may set the script wrapper to contain this placeholder only, which means the script wrapper will be looking like `%%USER_SCRIPT%%`. Though theoritically you can do it in this way, it's suggested not to do so, as the LSB application will lose the capability to get the output from your script properly. To get better understanding on this issue, please check the explanation for Intermediate data file below.</li>
  <li>**Intermediate data file** - **[Optional]** for many shells, there is no good way to convert script output in plain text into structured data. LSB provides this intermediate data file to capture all the outputs (must be in JSON format) from the user-defined script, and then the LSB will load and parse the data file to create structured data to be used in the LSB view. If the output from the user-defined script is not in JSON format, then the whole output will be recognized as a single string value.</li>
  <li>**First half of signature** and **Second half of signature** - **[Mandatory]** to detect the completion of the final script execution in the shell process, the LSB checks for a special flag in the script output. It first randomly generates a piece of signature data and splits it into two parts. The two parts are automatically assigned to two variables, i.e. the two signature placeholders, respectively, and then they are combined together to output the complete signature at the end of the wrapper script. When LSB detects the full signature in the shell output, it knows that the script execution reaches the end of the script. By splitting the signature into two parts, it ensures that no other place in the script could contain/output the full signature, preventing LSB from mistakenly thinking the script execution is completed before the actual end of the wrapper script.</li>
  <li>**Path to view file** - **[Optional]** this placeholder can be used in the wrapper script if it needs to access any file sitting in the same folder where the LSB view file is located.</li>
</ul>

When the LSB receives a request to execute a piece of user-defined script, it loads the wrapper script and replaces all the placeholders with actual values. The resulting script is then sent to the shell process for execution, and the LSB continuously monitors the shell output for the full signature. When the full signature shows up in the shell output, the LSB recognizes that the script execution completes. It then attempts to load the intermediate data file, parse the result data from it, and use the result data to refresh the view content and/or update the output parameters of the view control. If the intermediate data file is not used, then LSB uses the captured shell output as a single string value as the response from the script. If the full signature is not detected before the script execution timeout, the LSB terminates the script execution, attempts to parse the result data or the shell output, and refreshes the view content accordingly. If failures are captured during script execution, an error message will be displayed and no data will be returned.

*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_smart_time The Smart Time Input

Date and time are frequently used input data for LSB views, such as the start time and end time for a query against certain data/events which are created within the time range. The LSB application supports the date time and time span input in a very flexible way.

## Date time

### The Standard ISO format

The LSB supports the standard ISO date time in the any format of following,
 - **yyyy-MM-ddThh:mm:ss.nnn+zone** - Full ISO date time with positive time zone info
 - **yyyy-MM-ddThh:mm:ss.nnn-zone** - Full ISO date time with negative time zone info
 - **yyyy-MM-ddThh:mm:ss.nnnz** - GMT time with z as suffix
 - **yyyy-MM-ddThh:mm:ss.nnn(UTC)** - GMT time with (UTC) as suffix
 - **yyyy-MM-ddThh:mm:ss.nnn** - Full ISO date time for local time

And here are the meanings of each field used above,
 - **yyyy** - The full 4-digit year of the date time
 - **MM** - The month of the date time
 - **dd** - The day of the date time
 - **hh** - The hours of the date time
 - **mm** - The minutes of the date time
 - **ss** - The seconds of the date time
 - **nnn** - The milliseconds of the date time
 - **zone** - It is the time zone difference, specified in format of **hhmm**, i.e. hours and minutes
 - **z** - A simple character **z** or **Z** means that the date time is in GMT-0 time zone, i.e. the date time is an UTC time
 - **(utc)** or **(UTC)** - It means the date time is an UTC time
 - The characters not mentioned above are mandatory delimeters for the date time value, such as **-**, **T**, **:**, **.**, **+**, etc.

### The smart format
 
The LSB also supports inputting the date time in a flexible and smart format, see examples below,
 - **now** - This means the current time
 - **1 week 2 days and 3 hours ago** - It's for a time in the past compared to current time, specified through the suffix **ago**. If the current time is 2025-01-01T00:00:00, then the time specified with this string input is **2024-12-22T21:00:00**.
 - **1h 2m 3s later** - It's for a time in future compared to current time, indicated through the suffix **later**. If the current time is 2025-01-01T00:00:00, then the time specified with this string input is **2025-01-01T01:02:03**.

There are multiple time units could be used in the smart time format, and these time units must be presented in the following order, from large time unit to small time unit. Meanwhile, these units are all optional if the corresponding value is 0.
 - **week** - It could be specified with one of these words - **w**, **wk**, **week**, **weeks**. It simply equals to 7 days.
 - **day** - It could be specified with one of these words - **d**, **day**, **days**.
 - **hour** - It could be specified with one of these words - **h**, **hr**, **hour**, **hours**.
 - **minute** - It could be specified with one of these words - **m**, **min**, **minute**, **minutes**.
 - **second** - It could be specified with one of these words - **s**, **sec**, **second**, **seconds**
 - **and** - This word is used to connect multiple time parts in different units. It's optional. The space character does the same job to connect the multiple time parts in different units.

Besides, you can also use **year** or **month** individually to specify times,
 - **year** - It could be specified through one of these words - **y**, **yr**, **year**, **years**. Example values are **1 year ago**, **2 yr later**. One year simply equals to 365 days.
 - **month** - It could be specified through one of these words - **mon**, **month**, **months**. Example values are **2 months ago**, **3 mon later**. One month simply equals to 30 days.

As mentioned earlier, at the end of of the date time string, the **ago** suffix is appended for time in the past and the **later** suffix should be specified for time in future. And obviously, these two suffixes cannot be used together.

Please be reminded that the **year** and the **month** units can only be used solely, they cannot be used together, or with any of the previously explained **week**, **day**, **hour**, **minute** or **second**. It is very rare that there is need to specify a time with such large and small time units together. Even if there is need to specify time with large gap and fine resolution, the time could be specified through **week** or **day** for the large gap together with other units for fine resolution.

## Time span

### The standard format

Similiar to the date time, LSB supports standard time span in format of **d.hh:mm:ss.nnn**, where the fields mean,
 - **d** - The days for the time span. It could be any non-negative value, depends on how big the time span is. When the day is zero, the zero could be omitted together with the dot follows it.
 - **hh** - The hours part of the time span. It's mandatory and must be presented as **00** if the hour part in the time span is 0.
 - **mm** - The minutes part of the time span. It's mandatory and must be presented as **00** if the minute part in the time span is 0.
 - **ss** - The seconds part of the time span. It's mandatory and must be presented as **00** if the second part in the time span is 0.
 - **nnn** - The milliseconds part of the time span. It's optional. When it's present in the time span value, it must contain 3 digits. For milliseonds less than 100, they should be left padded by zero. When the milliseconds part is not present in the time span value, it means that the millisecond part is 0.

### The smart format

The LSB also supports time span with a smart format that is almost the same as the smart time, except the suffix of **ago** and **later**, which are not needed for the time span values. Here are some examples,
 - 1 week 2 days and 3 hours
 - 1 hour 23 minutes 45 seconds
 - 5 mins and 6 secs
 - 12 minute
 - 2 years
 - 3 mon

The LSB recognizes these values and will be automatically convert them into the corresponding time span values.

*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_smart_filter The Smart Filtering in ListView

The ListView control in LSB supports powerful client filtering through the embedded filter input control on the top. The filtering feature can be turned on/off through the **visible** attribute in the **filter** node (see the ListViewFilter) in the ListView definition. Here we will only discuss the features when the filter feature is turned on in the ListView, and how we can use the feature to quickly find item(s) in the ListView.

## Column based Filter

A filter is typically specified in the format of `column_name:filter_value`. Both the column name and the filter value could have double quotes wrapped. The double quotes are required only if there are one or more spaces contained in the column name or the filter value. If column name is not specified in a filter, then this filter value will be tested against all columns available in the ListView.

Here are some examples of the column based filter,
<ul>
<li>`ABC:123` is a valid column based filter. Here the `ABC` is the column name and `123` is the filter value. This filter means that for all items in a ListView, only if the column ABC contains value `123`, an item is considered matched and will be visible in the ListView. Items that have other columns contain value `123` but value in column `ABC` does not contain `123` are not recognized as matched item, and they will be invisible as long as the filter is applied.</li>
<li>`"AB C":"\d+A\d+"` is also a valid column based filter. Here the `"AB C"` is the column name and the `"\d+A\d+"` is the filter value. The double quotes in the column name are necessary as there is a space inside the column name. Meanwhile the double quotes in the filter value are optional. Besides, here the filter value is a regular expression. The LSB will use this regular expression pattern to test the values in columns to see if an item matches this filter.</li>
<li>`A B C:invalid` is a bit tricky. It looks like that double quotes are missing for the column name. Thus the value cannot be parsed as a valid column based filter in the form of `column_name:filter_value`. In this case, the whole string will be used as filter value as if the column name is missing. And as the filter value is not a valid regular expression, the LSB will then do simple string match test and all columns will be tested.</li>

## Filter Value

The LSB first tries to parse the filter value that user types in as a regular expression pattern, and then uses the created regular expression pattern to match test the values in corresponding column(s). If the specified filter value cannot be parsed as a regular expression, then the whole filter value will be used to do simple string match test. For example,
<ul>
<li>The value `A\d+B\d*` is a valid regular expression pattern, if the corresponding column contains values like A1B, A22B1, then the item is recognized as matched item.</li>
<li>The value `*\ABCD` cannot be parsed as regular expression, thus the string value is used to do simple match. Only if the corresponding column value contains `*\ABCD`, then the item will be considered as matched item.</li>
</ul>

As explained above, the filter value could be double quotes wrapped if the value contains space(s). The double quotes used to wrap the filter value won't be used as part of the pattern or string match. If there is no space in the filter value, then the double quote is unnecessary. If there is space in the filter value and we don't use quotes to wrap the value, it could be recognized as multiple filters. The only case that we may skip double quotes with space(s) in the input is that we want to use the whole input to do simple string match test.

## Combination of Column based Filters with Operators

We can put multiple column based filters together to create more complicated filters. For example, with `A:1 AND B:2 AND C:3` we setup a new filter that requires column A to contain value 1, column B to contain value 2 and column C to contain value 3. If and only if all three conditions are all met, an item in the ListView is considered as matched item. The operators supported to connect the filters are,
<ul>
<li>**AND**, upper case only. It means that the left filter and the right filter both need to be matched to declare an item matches the combined filter. The `&&` is another form of this operator.</li>
<li>**OR**, upper case only. It means that as long as one of the left filter and the right filter is matched, then the item is declared as matched. The `||` is another form of this operator.</li>
<li>**NOT**, upper case only. This is the not operator. When this operator is present, it means that the filter next to it must be unmatched to make the combined filter matched. For example, `NOT A:1` means that only if the value in column A does not contain value 1, then the item is recognized as matched item. The `!` is another form of this operator.</li>
</ul>

## Grouping of Filters

When the column based filters are connected through operators, it could become difficult to figure the result of the filter when there are multiple operators used together. For example, what does this filter mean?

  `A:1 AND B:2 OR A:3`

Does it have the same meaning as `A:3 OR B:2 AND A:1`? The answer is no. It takes time to figure out the actual meaning of these filters and realize that they are different.

To make the combined filters more clear and easy to read, we may use brackets to group the filters. Anything inside a pair of brackets will be treated like one filter when they are connected with other filters. For exmaples above, if we rewrite them as below,

  `A:1 AND (B:2 OR A:3)`<br/>
  `(A:3 OR B:2) AND A:1`

It becomes very easy to know that they have the same meanings, despite the actual symantic meanings of the filters.

*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_enum Enumeration Types

This page lists all the enumeration types that define the values for attributes in data classes and view controls in the LSB views.

@{
*/

//! \brief This is the enumeration type for specifying the content type for the about node in an LSB views.
/*!
This is used for the about information for the LSB views. The supported values are,
*/
enum class AboutDataType
{
  None,     //!< The about content is not specified. The about information will be generated from the settings for the LSB view.
  Content,  //!< The about node content will be directly used as the content for about information.
  Url       //!< The about node content is an URL to a Web page, the Web page will be used as the about information for the view.
};

//! \brief This is the enumeration type for chart type used for the attribute chartType in the ChartView.
/*!
It defines the chart types supported in the ChartView. The possible values are,
*/
enum class ChartType
{
  BarChart,            //!< This is value for displaying bar chart in the chart view control.
  StackedBarChart,     //!< This is value for displaying stacked bar chart in the chart view control.
  ColumnChart,         //!< This is value for displaying column chart in the chart view control.
  StackedColumnChart,  //!< This is value for displaying stacked column chart in the chart view control.
  BoxPlot,             //!< This is value for displaying box plot in the chart view control.
  CandlestickChart,    //!< This is value for displaying candlestick chart in the chart view control.
  OhlcChart,           //!< This is value for displaying OHLC chart in the chart view control.
  PieChart,            //!< This is value for displaying pie bar chart in the chart view control.
  DoughnutChart,       //!< This is value for displaying doughnut chart in the chart view control.
  PolarAreaChart,      //!< This is value for displaying polar area chart in the chart view control.
  BubbleChart,         //!< This is value for displaying bubble chart in the chart view control.
  ScatterPlot,         //!< This is value for displaying scatter plot in the chart view control.
  Math2dPlot,          //!< This is value for displaying math 2D plot in the chart view control.
  LineChart,           //!< This is value for displaying line chart in the chart view control.
  AreaChart,           //!< This is value for displaying area chart in the chart view control.
  Histogram,           //!< This is value for displaying histogram in the chart view control.
};

//! \brief This is the enumeration type for attribute contentType that is used in WebView.
/*!
It indicates the content type returned from the data source defined for the view control. The supported values are,
*/
enum class ContentType
{
  Url,      //!< The page should be loaded from the URL returned from the data source.
  Content,  //!< The page should be loaded from the raw content returned from the data source.
  File      //!< The page should be loaded from the files defined in the view definition.
};

//! \brief This is the enumeration type for attribute defaultPath that is used in FileTreeView.
enum class DefaultPathType
{
  None,                         //!< User to specify the path directly in the node content
  SystemConfig,                 //!< Path for the system configuration
  GlobalData,                   //!< Path for the global data folder
  TemporaryFolder,              //!< Path for the temporarily files
  ApplicationData,              //!< Path for application specific data folder
  ApplicationDocuments,         //!< Path for application documents folder
  ApplicationResources,         //!< Path for application resources folder
  Plugins,                      //!< Path for application plugins folder
  UserCache,                    //!< Path for the user's cache folder
  UserConfig,                   //!< Path for the user's configuration folder
  UserData,                     //!< Path for the user's data folder
  UserDesktop,                  //!< Path for the user's desktop folder
  UserDocuments,                //!< Path for the user's documents folder
  UserLocalData,                //!< Path for the user's local data folder
  UserMusic,                    //!< Path for the user's music folder
  UserPicture,                  //!< Path for the user's picture folder
  UserVideos,                   //!< Path for the user's video folder
};

//! \brief This is the enumeration type for the view parameter direction.
/*!
This type is used internally in the LSB code, not directly used in the LSB views. The supported values are,
*/
enum class Direction
{
  Input,    //!< The parameter is used as input parameter for the view control.
  Output    //!< The parameter is used as output parameter for the view control.
};

//! \brief This is the enumeration type for the attribute dock in the Button control.
/*!
It defines how the button will be docked in the space reserved for it. The supported values are,
*/
enum class DockStyle
{
  None,     //!< This means the button is not docked, it will have its default size.
  Left,     //!< This means the button is docked to left of the space, taking full height of the space and keep the default width.
  Top,      //!< This means the button is docked to top of the space, taking full width of the space and keep the default height.
  Right,    //!< This means the button is docked to right of the space, taking full height of the space and keep the default width.
  Bottom,   //!< This means the button is docked to bottom of the space, taking full width of the space and keep the default height.
  Fill      //!< This means the button will take the whole reserved space. This indirectly provides the capability to control the button size through the layout control.
};

//! \brief This is the enumeration type for the attribute whenToExecute on the Procedure node.
/*!
It controls when a Procedure executes the script associated with it. The supported values are,
*/
enum class WhenToExecute
{
  ParameterChanging,      //!< The script is kicked off when the input parameter(s) for the Procedure is changed
  OneShotInitializing,    //!< The script is kicked off when the Procedure is initialized, the script is executed once only
  TimerTicking,           //!< The script is kicked off each time the timer associated with the Procedure approaches the interval
  TimerStartAndTicking    //!< The script is kicked off when the timer associated with the Procedure is started and approaches interval
};

//! \brief This is the enumeration type used for the fixedView attribute in the SplitLayout.
/*!
It indicates which pane in the SplitLayout control has fixed size. The supported values are,
*/
enum class FixedView
{
  None,     //!< None of the two panes have fixed size, i.e. both panes are resizable when the view window resizes.
  Left,     //!< The left pane in the split layout control has fixed size, i.e. it does not resize when the view window resizes.
  Right,    //!< The right pane in the split layout control has fixed size.
  Top,      //!< The top pane in the split layout control has fixed size.
  Bottom    //!< The bottom pane in the split layout control has fixed size.
};

//! \brief This is the enumeration type for standard font families.
/*!
Please check <a href="https://docs.wxwidgets.org/3.2/interface_2wx_2font_8h.html#a0cd7bfd21a4f901245d3c86d8ea0c080">wxFontFamily</a> on the wxWidgets Web site for more details. The supported values are,
*/
enum class FontFamily
{
  Default,      //!< A default font.
  Decorative,   //!< A decorative font.
  Roman,        //!< A formal, serif font.
  Script,       //!< A handwriting font.
  Swiss,        //!< A sans-serif font.
  Modern,       //!< A fixed pitch font.
  Teletype      //!< A teletype (i.e. monospaced) font.
};

//! \brief This is the enumeration type for font styles.
/*!
Please check <a href="https://docs.wxwidgets.org/3.2/interface_2wx_2font_8h.html#ab8f87d0b928ad1f8cba7d1c01f5f7a55">wxFontStyle</a> on the wxWidgets
for more details. The supported values are,
*/
enum class FontStyle
{
  Normal,       //!< The font is drawn without slant.
  Italic,       //!< The font is slanted in an italic style.
  Slant         //!< The font is slanted, but in a roman style.
};

//! \brief This is the enumeration type for font weight.
/*!
Please check <a href="https://docs.wxwidgets.org/3.2/interface_2wx_2font_8h.html#a7cc37d08c7e84370f4fcc175b557a022">wxFontWeight</a> on the wxWidgets for more details. The supported values are,
*/
enum class FontWeight
{
  Thin,         //!< Thin font (weight = 100).
  ExtraLight,   //!< Extra Light (Ultra Light) font (weight = 200).
  Light,        //!< Light font (weight = 300).
  Normal,       //!< Normal font (weight = 400).
  Medium,       //!< Medium font (weight = 500).
  SemiBold,     //!< Semi Bold (Demi Bold) font (weight = 600).
  Bold,         //!< Bold font (weight = 700).
  ExtraBold,    //!< Extra Bold (Ultra Bold) font (weight = 800).
  Heavy,        //!< Heavy (Black) font (weight = 900).
  ExtraHeavy    //!< Extra Heavy font (weight = 1000).
};

//! \brief This is the enumeration type for HexView to configure the type of data returned from data source.
enum class HexViewDataType
{
  Data,        //!< The HexView uses data returned from data source directly
  File         //!< The HexView uses data returned from data source as file name to load data from
};

//! \brief This is the enumeration type used for the align attribute in the Column.
/*!
It indicates how the content in the column will be aligned horizontally. The supported values are,
*/
enum class HorizontalAlignment
{
  Center,       //!< The content in the column will be center-aligned.
  Left,         //!< The content in the column will be left-aligned.
  Right         //!< The content in the column will be right-aligned.
};

//! \brief This is the enumeration type used for the method attribute in the WebData.
/*!
It indicates which HTTP method should be used for the web request to download data for the view control. The supported values are,
*/
enum class HttpMethod
{
  Get,      //!< The web request uses GET method to download data from the web endpoint.
  Post,     //!< The web request uses POST method to download data from the web endpoint.
};

//! \brief This is the enumeration type for known paths for file references.
/*!
The known paths are all relative to the LSB applciation folders except None, which is for raw path. The supported values are,
*/
enum class KnownPath
{
  None,     //!< It's not using any known path, the content is raw path, which could be platform specific.
  View,     //!< The path is pointint to the view folder.
  Libs,     //!< The path is pointing to the libs folder.
  Data,     //!< The path is pointing to the data folder.
  Temp      //!< The path is pointing to the temp folder.
};

//! \brief This is the enumeration type for the chart line types.
/*!
The supported values are,
*/
enum class LineType
{
  Straight, //!< Straight line is used for drawing the lines in ChartView.
  Stepped   //!< Stepped line is used for drawing the lines in ChartView.
};

//!< \brief This is the enumeration type for the view attribute loadDataAt.
/*!
This attribute indicates when to load data for a view control. The supported values are,
*/
enum class LoadDataAt
{
  Default,      //!< Data for the view will be loaded when there is change in the input parameters.
  Creating,     //!< Data for the view will be loaded when the view is created.
  Visualizing   //!< Data for the view will be loaded when the view becomes visible for the first time. By using this value, it could be helpful to reduce the loading time for an LSB view, especially when there are many view controls need to load data at the beginning. Using this value will defer the data loading from LSB view creating time to when a view control becomes visible.
};

//! \brief This is the enumeration type used for the activation attribute of OutputParameter,
/*!
It indicates which operation would trigger the ouput parameter value changed event and send out the changed parameter values. The supported values are,
*/
enum class OperationType
{
  Default,      //!< The default operation on the view control, which is same as Selecion.
  Selection,    //!< When an item or content is selected in the view control, it will trigger the OutputParameter changed event.
  Activation,   //!< The activation operation in the view control, which is same as DoubleClick.
  DoubleClick   //!< When an item in view control is double clicked, it will trigger the OutputParameter changed event.
};

//! \brief This is the enumeration type used for the orientation attribute in the SplitLayout.
/*!
It indicates the layout direction of the two panes in the SplitLayout. The supported values are,
*/
enum class Orientation
{
  Horizontal,   //!< The two panes are placed horizontally, one in left and one in right.
  Vertical      //!< The two panes are placed vertically, on in top and one in bottom.
};

//! \brief This is the enumeration type for the attribute type in the PropertyField configuration.
/*!
It defines which value type is used for the property definition. The supported values are,
*/
enum class PropertyValueType
{
  Boolean,          //!< The value is in boolean type.
  Flags,            //!< The value is a flags value, which means each bit in the value is an unique flag.
  Float,            //!< The value is a float value.
  Integer,          //!< The value is an integer value.
  UnsignedInteger,  //!< The value is an unsigned integer value.
  String,           //!< The value is a string value.
  Password,         //!< The value is a string value for password.
  ArrayString,      //!< The value is a string array.
  LongString,       //!< The value is a multiple line string value.
  Enumeration,      //!< The value is in an enumeration type.
  MultiChoice,      //!< The value allows selection from multiple values.
  Date,             //!< The value is a date value.
  Font,             //!< The value is a font value.
  Cursor,           //!< The value is a cursor.
  Color,            //!< The value is a color.
  SystemColor,      //!< The value is one of the system colors.
  File,             //!< The value is a file.
  ImageFile,        //!< The value is an image file.
  Folder            //!< The value is a folder.
};

//! \brief This is the enumeration type for defining the size type of table rows and table columns.
/*!
It defines how the actual size of table row or table column are calculated. The supported values are,
*/
enum class SizeType
{
  Absolute,     //!< The size is specified as absolute pixels.
  Percentage    //!< The size is specified as percentage of totoal size.
};

//! \brief This is the enumeration type used for the tabPosition attribute in the TabLayout.
/*!
It indicates the position of the tab bar in the TabLayout. The supported values are,
*/
enum class TabPosition
{
  Top,      //!< The tab bar will be put at the top of the tab layout control. This is the default value.
  Bottom,   //!< The tab bar will be put at the bottom of the tab layout control.
  Left,     //!< The tab bar will be put at the left side of the tab layout control.
  Right     //!< The tab bar will be put at the right side of the tab layout control.
};

//! \brief This is the enumeration type used in the InputParameter to indicate what kind of changes happened to the InputParameter when an input parameter changes event is sent out.
/*!
These flags are implemented as properties on the parameters available in Lua script. The supported values are,
*/
enum class TriggerFlags
{
  IsNull,       //!< The input parameter value is null.
  IsEmpty,      //!< The input parameter value is an empty string.
  IsWhiteSpace, //!< The input parameter value contains whitespace only, not an empty string.
  IsTrue,       //!< The input parameter value is boolean value true.
  IsFalse,      //!< The input parameter value is boolean value false.
  IsZero,       //!< The input parameter value is 0.
  IsPositive,   //!< The input parameter value is a positive value, greater than 0.
  IsNegative,   //!< The input parameter value is a negative value, less than 0.
  IsMatched,    //!< The input parameter value matches the specified regular expression pattern for the parameter.
  IsChanged,    //!< The input parameter value is changed.
  IsTrigger     //!< The input parameter is the one triggered the check.
};

//! \brief This is the enumeration type of how to trim spaces in a string value.
/*!
The supported values are,
*/
enum class TrimSpace
{
  None,     //!< The string value won't be trimmed.
  Left,     //!< Only the left spaces in the string value will be trimmed.
  Right,    //!< Only the right spaces in the string value will be trimmed.
  Both      //!< Both left and right spaces in string will be trimmed.
};

//! \brief This is the enumeration type for when to send out text change event from the TextInput control.
/*!
The supported values are,
*/
enum class WhenToNotify
{
  Enter,        //!< The text control sends text change event when enter key is pressed in the TextInput control.
  TextChange,   //!< The text control sends text change event when the text content is changed.
  Both          //!< The text control sends text change event on both cases - text content is changed or enter key is pressed.
};

/*!
@}
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_data Data Classes

This page lists all the data types and data classes that are used for data nodes used in the LSB view files.
@{
*/

//! \brief This is the node for defining content of about information for an LSB view.
/*!
 - The content of this node is for the about information for an LSB view.
*/
class About
{
  public AboutDataType type;        //!< [Mandatory] This attribute defines the type of content in the About node.
};

//! \brief This node is used to define one of the supported data sources for a view control.
/*!
There is no specific node name for this node. Only one of the following data source nodes are accepted.
 - csv - The data source is using the CsvData, i.e. data is downloaded through HTTP Web request and is in CSV format.
 - json - The data source is using the JsonData, i.e. data is downloaded through HTTP Web request and is in JSON format.
 - sql - The data source is using the SqlData, i.e. data is downloaded through SQL query.
 - script - The data source is using the ScriptData, i.e. data is generated through the script execution.
*/
class ChoiceOfData
{
  public bool showProgress;     //!< [Optional] This attribute defines if a progress dialog should be shown during the retrieval of data. The default value is false.
};

//! \brief This node is used to select one of the following supported view controls.
/*!
There is no specific node name for this node. Only one of the following control nodes are accepted.
 - splitLayout - The node is specified to use the SplitLayout control.
 - tabLayout - The node is specified to use the TabLayout control.
 - tableLayout - The node is specified to use the TableLayout control.
 - buttonGroup - The node is specified to use the ButtonGroup control.
 - chartView - The node is specified to use the ChartView control.
 - listView - The node is specified to use the ListView control.
 - textView - The node is specified to use the TextView control.
 - treeListView - The node is specified to use the TreeListView control.
 - treeView - The node is specified to use the TreeView control.
 - webView - The node is specified to use the WebView control.
 - button - The node is specified to use the Button control.
 - propertyInput - The node is specified to use the PropertyInput control.
 - textInput - The node is specified to use the TextInput control.
 - comboBox - The node is specified to use the ComboBox control.
*/
class ChoiceOfView
{
};

//! \brief This is color type that supports either CssColor or HtmlColor.
class Color
{
};

//! \brief This node defines the color settings to be used in the ChartView control.
class ColorSetting
{
  public Color fillColor;           //!< [Optional] The color for filling.
  public Color borderColor;         //!< [Optional] The color for borders.
  public Color lineColor;           //!< [Optional] The color for lines.
};

//! \brief This node defines the attributes on the Column node to be used in the ListView and TreeListView controls.
class Column
{
  public string name;                   //!< [Mandatory] This is the name for the column. It's also used to find the member in the corresponding data object.
  public string displayName;            //!< [Optional] Display name for the column header. If it's not specified, then the value in the name is used.
  public int width;                     //!< [Optional] This is attribute for the column width.
  public HorizontalAlignment align;     //!< [Optional] This is attribute that controls how th value in the column is aligned. The default value is Left.
  public bool visible;                  //!< [Optional] This is attribute that controls if the column is visible. The default value is true.
};

//! \brief This node defines a set of columns to be used in the ListView or TreeListView controls.
/*!
This is a container node for the following single type of nodes.
 - column - A set of Column nodes for columns in the ListView or TreeListView controls.
*/
class ColumnSet
{
};

//! \brief This is an attribute group, it defines the attributes that are used in all components. This is the base attribute set for all view controls, Procedure and ViewLauncher components.
class ComponentAttributes
{
  public UUID id;       //!< [Mandatory] This attribute in type UUID is an attribute for all components.
};

//! \brief This is a node group, it defines the common child nodes for all components. It is the base child node set of all view controls, Procedure and ViewLauncher components.
/*!
Following nodes can be included, and each one of them can appear at most once.
 - input - [Optional] This node of InputParam defines the input parameters for the component.
 - output - [Optional] This node of OutputParam defines the output parameters for the component.
 - condition - [Optional] This node contains a piece of Lua script, defines the logic to determine if the input paramter value changes should trigger data source elevation.
 - data - [Optional] This node of ChoiceOfData defines the data source for the component.
*/
class ComponentElements
{
};

//! \brief This is the node of ContextMenu for defining a context menu in LSB view controls.
/*!
It contains at least one of following items and there is no upper boundary on the node count.
 - menuItem - [Optional] This child node in type of ContextMenuItem is used for defining menu items in the context menu.
 - separator - [Optional] This child node in type of ContextMenuSeparator is used for defining separators in the context menu.
 - subMenu - [Optional] This child node in type of ContextMenuSubMenu is used for defining sub-menus in the context menu.
*/
class ContextMenu
{
  public bool copy;         //!< [Optional] This boolean attribute controls if the copy menu items should be enabled. The default value is false.
  public bool refresh;      //!< [Optional] This boolean attribute controls if the refresh menu item should be enabled. The default value is false. This refresh menu item will automatically load the data from the associated data source and refresh the context in the view control.
};

//! \brief This is the node of ContextMenuItem used for context menu item.
/*!
It may contain following nodes as child.
 - output - [Optional] This child node is in type of OutputParamSet and defines all output parameters specific for this menu item.
 - data - [Optional] This child node is in type of ChoiceOfData for the data source associated with this menu item.
*/
class ContextMenuItem
{
  public string text;       //!< [Mandatory] This is the attribute for the context menu item text.
};

//! \brief This is the node of ContextMenuSeparator for separator in context menu.
/*!
There is no content, attribute or child node for this node.
*/
class ContextMenuSeparator
{
};

//! \brief This is the node of ContextMenuSubMenu for sub-menu in context menu.
/*!
It should contain at least one of following nodes and there is no upper boundary on the node count.
 - menuItem - [Optional] This child node is in type of ContextMenuItem. It's for menu items in the sub-menu.
 - separator - [Optional] This child node is in type of ContextMenuSeparator. It's for separators in the sub-menu.
 - subMenu - [Optional] This child node is in type of ContextMenuSubMenu. It's for sub-menus in the sub-menu - the sub-menus could be nested.
*/
class ContextMenuSubMenu
{
  public string text;       //!< [Mandatory] This is the attribute for sub-menu text in the context menu.
};

//! \brief This is the CSS color type in format of rgb(r, g, b) or rgba(r, g, b, a).
class CssColor
{
};

//! \brief This is the node to define the configuration for downloading CSV data from an URL through HTTP Web request.
class CsvData : public WebData
{
  public string delimeter;      //!< [Optional] This attribute defines the delimeter used for separating the columns in CSV data.
};

//! \brief This node defines a set of parameter mapping from an output parameter (source) to one or more input parameters (target).
/*!
This node contains a set of mapping nodes for each source parameter.
 - mapping - These nodes are in type of Mapping. It defines the mapping from one source parameter to one or more target parameters.
*/
class DataFlow
{
};

//! \brief This node defines the file reference to be used in WebView.
/*!
 - content - The content of this node is the actual path (if KnownPath is set to None) or file name (if KnownPath is set to value other than None) for the file reference.
*/
class FileReference
{
  public KnownPath path;        //!< [Optional] This attribute defines the known path type. The default value is None,
};

//! \brief This node defines a set of FileReference to be used in the WebView.
/*!
This node contains a set of reference nodes for each file reference.
 - reference - A set of reference nodes in type of FileReference for the file references to be used in the WebView.
*/
class FileReferences
{
};

//! \brief This is the node that defines font description, for defining fonts to be used in LSB views.
class FontDesc
{
  public unsigned int encoding;    //!< [Optional] This is an attribute for the font encoding, the default value is 33.
  public FontFamily family;        //!< [Optional] This is an attribute for the font family, the default value is Default.
  public unsigned int pointSize;   //!< [Mandatory] This is an attribute for the font size in points.
  public FontStyle style;          //!< [Optional] This is an attribute for the font style, the default value is Normal.
  public FontWeight weight;        //!< [Optional] This is an attribute for the font weight, the default value is Normal.
  public bool underline;           //!< [Optional] This is an boolean attribute that controls if the font should be underlined, the default value is false.
  public bool strikethrough;       //!< [Optional] This is an boolean attribute that controls if the font should be strikethrough, the default value is false.
  public string faceName;          //!< [Mandatory] This is the attribute for the font face name.
};

//! \brief This node defines the highlight settings used in WebView for highlighting text.
class HighlightSetting
{
  public string name;           //!< [Mandatory] This attribute defines the name for the highlight setting.
  public string pattern;        //!< [Mandatory] This attribute defines the regular expression pattern to match test the content to be highlighted.
  public HtmlColor backColor;   //!< [Optional] This attribute defines the background color for the text to be highlighted.
  public HtmlColor foreColor;   //!< [Optional] This attribute defines the foreground color for the text to be highlighted.
};

//! \brief This is HTML color type in format of \#rrggbb.
class HtmlColor
{
};

//! \brief This is the node that defines the InputParam for input parameters.
class InputParam : public Parameter
{
  public string valuePattern;   //! [Optional] This is an attribute that defines the value pattern for the input parameter. Only if the input parameter value matches the pattern, then operations will be triggered. The default value of this pattern is empty, which means no pattern is defined.
};

//! \brief This is the node for the InputParamSet, contains a set of InputParam nodes.
/*!
 - param - A set of parameter nodes in type of InputParam.
*/
class InputParamSet
{
};

//! \brief This is the node to define the configuration for downloading JSON data from an URL through HTTP Web request.
class JsonData : public WebData
{
  public string path;           //!< [Optional] The data returned remote URL is JSON object or JSON array. This attribute defines the path within the JSON object or JSON array to the actual data to be returned to LSB view. If this path is not specified, the whole downloaded JSON data is returned.
};

//! \brief This node defines the filter setting for ListView.
class ListViewFilter
{
  public bool visible;              //!< [Optional] This attribute defines if the filter control is visible in ListView. The default value is true.
  public string prompt;             //!< [Optional] This attribute defines the prompt text for the filter input. The default value is empty, which means there is no prompt text.
  public string placeholder;        //!< [Optional] This attribute defines the placeholder text in the filter input when the actual value is empty. The default value is empty.
};

//! \brief This node defines the status bar setting for the ListView.
class ListViewStatus
{
  public bool visible;                      //!< [Optional] This attribute defines if the status bar is visible for ListView. The default value is true.
  public string singleItemCountPrompt;      //!< [Optional] This attribute defines the prompt text when there is only one item in the ListView. %%ITEM_COUNT%% is the placeholder for the item count.
  public string multipleItemCountPrompt;    //!< [Optional] This attribute defines the prompt text when there are multiple items in the ListView. %%ITEM_COUNT%% is the placeholder for the item count.
  public string noSelectionPrompt;          //!< [Optional] This attribute defines the prompt text when there is no item selected in the ListView.
  public string currentSelectionPrompt;     //!< [Optional] This attribute defines the prompt text for showing current selection in ListView. %%ITEM_INDEX%% is the placeholder for the currently selected item index.
  public string singleSelectionPrompt;      //!< [Optional] This attribute defines the prompt text when there is only one item selected in the ListView.
  public string multipleSelectionPrompt;    //!< [Optional] This attribute defines the prompt text when there are multiple items selected in the ListView.
};

//! \brief This node defines the parameter mapping from one output parameter (source) to one or more input parameter (target).
/*!
This node may contain one to many target nodes.
- target - The target node defines the unique ID of the target parameter (InputParam). The target node has the UUID as its content, no attributes on it.
*/
class Mapping
{
  public UUID source;       //!< [Mandatory] This attribute defines the unique ID of the source parameter (OutputParam).
};

//! \brief This node defines a single option that could be used in the ComboBox or PropertyInput control.
/*!
 - content - It's the option value.
*/
class Option
{
  public string group;          //!< [Optional] This attribute defines the group that the option belongs to.
};

//! \brief This node defines a set of options to be used in the ComboBox or PropertyInput control.
/*!
 - option - A set of option nodes for the options to be used in the ComboBox or PropertyInput control.
*/
class OptionList
{
};

//! \brief This is the OS type that defines which operating system that the LSB view supports.
/*!
The value could be one of the values below, or a combination of them separated by semi-colon.
  - Any - This is equivalent to Windows;Linux;MacOS
  - Windows - The LSB view supports Windows system
  - Linux - The LSB view supports Linux system
  - MacOS - The LSB view supports Mac OS X system
*/
class OS
{
};

//! \brief This is the node that defines the OutputParam for output parameters.
class OutputParam : public Parameter
{
  public OperationType activation;  //!< [Optional] This is an attribute that defines which operation in the view control would trigger the activation of parameter change. The default value is Default.
};

//! \brief This is the node for the OutputParamSet, contains a set of OutputParam.
/*!
 - param - A set of param nodes in type of OutputParam.
*/
class OutputParamSet
{
};

//! \brief This is the node for the Parameter. It's the base class for InputParam and OutputParam.
class Parameter
{
  public UUID id;       //!< [Mandatory] The unique ID of the parameter.
  public string name;   //!< [Mandatory] Name of the parameter.
};

//! \brief This node defines the prompt text for the ComboBox and TextInput.
/*!
 - content - It's the prompt text to be displayed.
*/
class Prompt
{
  public bool visible;          //!< [Optional] This boolean flag controls if the prompt should be visible.
  public bool exclusive;        //!< [Optional] This boolean flag controls if the prompt should be displayed in exclusive line.
};

//! \brief This node defines the configuration for a property field to be used in PropertyInput control.
/*!
 - options - [Optional] This child node defines the option list when the property is in a type needs options support.
*/
class PropertyField
{
  public string name;               //!< [Mandatory] This attribute defines the name for the property.
  public PropertyValueType type;    //!< [Mandatory] This attribute defines the value type for the property.
  public string label;              //!< [Optional] This attribute defines the label for the property. If it's empty, then the name will be used for label.
  public string category;           //!< [Optional] This attribute defines the category for the property.
  public string description;        //!< [Optional] This attribute defines the description text for the property.
  public string default;            //!< [Optional] This attribute defines the default value for the property.
  public string fileTypes;          //!< [Optional] This attribute defines the file types supported by the property. It is used in the popup dialog when user tries to select a file.
  public string initialPath;        //!< [Optional] This attribute defines the initial path for the file property. It is used in the popup dialog when user tries to select a file.
};

//! \brief This node defines the font and style setting for condition matched rows in the ListView and TreeListView control.
/*!
 - font - This child node defines the font to be used in the matched row.
*/
class RowStyle
{
  public string condition;          //!< [Mandatory] This string attribute contains the row condition written the same syntax as the smart filter for ListView, see \ref section_smart_filter. The matched row will be displayed using the configured font and colors.
  public FontDesc font;             //!< [Optional] This attribute defines the font to be used for the matched row.
  public Color foreColor;           //!< [Optional] This attribute defines foreground color for the matched row.
  public Color backColor;           //!< [Optional] This attribute defines background color for the matched row.
};

//! \brief This is the node that defines the configuration for generating data through script execution.
/*!
 - content - The content of this node is the script to be executed for generating the data.
*/
class ScriptData
{
  public string type;           //!< [Mandatory] This attribute defines the type of the script, see \ref section_settings on how to configure shells to support more script types. The Lua is an embedded script language and always supported.
  public unsigned int timeout;  //!< [Optional] This attribute defines the timeout for the script execution. The default value is 0, which means it will use the LSB global timeout setting for the script execution timeout.
};

//! \brief This is the node that defines the configuration for retrieving data through SQL query.
/*!
 - content - The content of this node is the query statement to be executed to search for the data in the database.
*/
class SqlData
{
  public string server;         //!< [Mandatory] This attribute indicates the database server to connect to.
  public string database;       //!< [Mandatory] This attribute indicates the name of the database that contains the data.
  public string user;           //!< [Optional] This attribute defines the user name to be used for connecting to the database.
};

//! \brief This node is used for defining the table cell in the TableLayout control.
/*!
This node is derived from ChoiceOfView and uses one of the supported view controls as child node of it. Besides, it has some extra attributes.
*/
class TableCell : public ChoiceOfView
{
  public unsigned int row;          //!< [Mandatory] This attribute defines row of the table cell.
  public unsigned int col;          //!< [Mandatory] This attribute defines column of the table cell.
  public unsigned int rowSpan;      //!< [Optional] This attribute defines the row span of the table cell. The default value is 1.
  public unsigned int colSpan;      //!< [Optional] This attribute defines the column span of the table cell. The default value is 1.
};

//! \brief This node defines the table column sizing settings.
class TableColumn
{
  public SizeType sizeType;         //!< [Mandatory] This attribute defines how the width is specified for the table column.
  public unsigned short width;      //!< [Mandatory] This attribute defines the width of the table column.
};

//! \brief This node defines the table row sizing settings.
class TableRow
{
  public SizeType sizeType;         //!< [Mandatory] This attribute defines how the height is specified for the table row.
  public unsigned short height;     //!< [Mandatory] This attribute defines the height of the table row.
};

//! \brief This node is used for defining the tab page in the TabLayout control.
/*!
It's derived from ChoiceOfView and uses one of the supported view controls as child node of it. Besides, it has one extra attribute.
*/
class TabPage : public ChoiceOfView
{
  public string title;      //!< [Mandatory] This is an attribute that defines the title for the tab page.
};

//! \brief This is the 16-byte unique ID.
/*!
The string representation of an UUID is 8-4-4-4-12 hexadecimal digits. One example of UUID string is b0db8ea8-2c10-4c20-9888-d4d0e91a00f0.
*/
class UUID
{
};

//! \brief This is the node for defining version information.
class Version
{
  public unsigned short major;      //!< [Mandatory] This is the major number in the version.
  public unsigned short minor;      //!< [Mandatory] This is the minor number in the version.
  public unsigned short build;      //!< [Optional] This is the build number in the version. The default value is 0.
  public unsigned short revision;   //!< [Optional] This is the revision part in the version. The default value is 0.
};

//! \brief This group defines the attributes for all views.
/*!
It includes all attributes defined in the ComponentAttributes.
*/
class ViewAttributes : public ComponentAttributes
{
  public LoadDataAt loadDataAt;     //!< [Optional] This attribute defines when the view should load the data. The default value is Default.
};

//! \brief This is the node that defines the caption of an LSB view control.
/*!
 - content - The content of this node is for the view caption.
 */
class ViewCaption
{
  public bool visible;          //!< [Optional] This is a boolean attribute that controls if the view caption is visible, the default value is true.
};

//! \brief This group defines the child nodes for all views.
/*!
It includes all elements defined in the ComponentElements.
 - caption - [Optional] This node defines the caption for the view.
 - contextMenu - [Optional] This node defines the context menu for the view.
*/
class ViewElements : public ComponentElements
{
};

//! \brief This is the base node to define the configuration for downloading data from an URL through HTTP Web request.
/*!
Following nodes can be specified under this node,
 - url - [Mandatory] The content of this child node defines the URL for the request. There is no attribute on this child node.
 - payload - [Optional] The content of this child node contains the payload used for the request. It's only used when the request method is set to Post.
*/
class WebData
{
  public HttpMethod method;     //!< [Optional] This attribute defines the HTTP Web method used for the request. The default value is Get.
  public string contentType;    //!< [Optional] This attribute defines the content type for the HTTP Web request.
};

//! \brief This node defines the data column for the X axis used in the ChartView control.
class XAxisColumn
{
  public string name;               //!< [Mandatory] This attribute defines the name of the data column.
  public string displayName;        //!< [Optional] This attribute defines the display name for the data column. If it's not specified, then the value of the name is used.
  public bool isDateTime;           //!< [Optional] This attribute defines if the data column is in type of datetime. The default value is false.
};

/*!
@}
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_view View Controls
This page contains the list of all view controls supported in the LSB application.

- Layout Controls
  - ButtonGroup
  - SplitLayout
  - TabLayout
  - TableLayout
- Data View Controls
  - ChartView
  - FileList
  - FileTree
  - HexView
  - ListView
  - TextView
  - TreeListView
  - TreeView
  - WebView
- Input Controls
  - Button
  - ComboBox
  - TextInput
  - PropertyInput
- Invisible Components
  - Procedure
  - ViewLauncher

@{
*/

//! \brief The ButtonGroup is a layout control that automatically arranges a group of buttons in the designated area based on preset rules.
/*!
The ButtonGroup supports two ways to arranges the buttons in the group.
 - If autoFlow attribute is set to true, then the buttons are automatically arranged based on their natural width (based on the text length in the label). It puts the buttons one by one in the same row. When the remaining space in the row is not big enough to fit in the next button, then the next button will be put into a new row. The button thereafter will be put after this button in the new row following the same arranging rule.
 - If autoFlow is set to false, then the number of buttons in a row is determined by the value specified in the attribute buttonsPerRow. The buttons will be resized to fit in the space in a row, despite the actual text length in the button.

This ButtonGroup node contains following child nodes,
 - All the nodes defined in ViewElements.
 - buttons - This node contains a set of button nodes where each of the nodes is in type of Button.

This ButtonGroup node contains following attributes,
 - All the attributes defined in the ViewAttributes
 - Plus following attributes,
*/
class ButtonGroup : public ViewElements, public ViewAttributes
{
  public bool autoFlow;                 //!< [Optional] This boolean attribute defines if the buttons would auto-flow to next row when the total width exceeds the space in the row.
  public unsigned int buttonsPerRow;    //!< [Optional] This attribute defines how many buttons will be put in each row when the autoFlow is set to false.
};

//! \brief The SplitLayout is a layout control that supports hosting two child views side by side.
/*!
Here are the SplitLayout features,
 - The two child views supported by SplitLayout could be any data view controls, input controls, or layout controls including SplitLayout itself.
 - Depends on the orientation configured for the SplitLayout, the two child views could be placed either horizontally (one in left and another one in right) or vertically (one in top and another one in bottom).
 - One of the child views could have fixed size, or both of them could be resizable at the same time when the SplitLayout control size changes.
 
The SplitLayout node contains following child nodes,
 - All the nodes defined in ViewElements.
 - The left node and right node if the orientation is set to Horizontal, both nodes are in type of ChoiceOfView.
 - The top node and bottom node if the orientation is set to Vertical, both nodes are in type of ChoiceOfView.

The SplitLayout node contains following attributes,
 - All the attributes defined in the ViewAttributes.
 - Plus following attributes,
*/
class SplitLayout : public ViewElements, public ViewAttributes
{
  public Orientation orientation;   //!< [Optional] This attribute defines the orientation of the two child views in SplitLayout. The default value is Horizontal.
  public FixedView fixedView;       //!< [Mandatory] This attribute defines which one of the two child views has fixed size.
  public double ratio;              //!< [Optional] When the fixedView is set to None, this attribute defines the ratio of how the two child views split the client size, either in width (if orientation is set to Horizontal) or in eight (if orientation is set to Vertical).
  public unsigned int size;         //!< [Optional] When the fixedView is set to value other than None, this attribute defines the size of the fixed size child view.
};

//! \brief The TabLayout is a layout control that arranges child views in tab pages.
/*!
The TabLayout layout control uses the TabControl to arrange multiple child views in tab pages, one child view in each tab page. The child views in each tab page could be data view controls, input controls or layout controls including TabLayout itself.

This TabLayout node contains following child nodes,
 - All the nodes defined in ViewElements.
 - pages - This is the parent node for all page nodes in type of TabPage. There should be at least one page under the pages node, and there is no upper boundary on the page count.

This TabLayout node contains following attributes,
 - All the attributes defined in the ViewAttributes.
 - Plus following attributes,
*/
class TabLayout : public ViewElements, public ViewAttributes
{
  public bool multiLine;            //!< [Optional] This boolean attribute controls if the tab headers in the tab control is displayed in multiple rows. The default value is false.
  public TabPosition tabPosition;   //!< [Optional] This attribute defines in which side of the TabControl should the tab headers be displayed. The default value is Top. 
};

//! \brief This TableLayout is a layout control that arranges multiple child views in a table layout.
/*!
The TableLayout arranges the child views in a way similar to the HTML table. It supports child views including data view controls, input controls, and layout controls. Each child view can have customized position and size settings similar to the HTML cells in HTML table.

This TableLayout node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Mandatory] The rows node defines how the size of each row is determined. It contains a set of row elements. Each row element is in type of TableRow.
 - [Mandatory] The columns node defines how the size of each column is determined. It contains a set of column elements. Each column element is in type of TableColumn.
 - [Mandatory] The cells node defines the position and size of child views, as well as which child view is placed inside the table cell. It contains a set of cell nodes. Each cell node is in type of TableCell.

This TableLayout node contains following attributes,
 - All the attributes defined in the ViewAttributes.
*/
class TableLayout : public ViewElements, public ViewAttributes
{
};

//! \brief This ChartView is a data view control that uses the wxChart control to render data as charts.
/*!
Please refer to <a href="https://github.com/wxIshiko/wxCharts">wxChart</a> to see more details on which charts are supported by the this ChartView control.

This ChartView node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Mandatory] The xAxis node in type of XAxisColumn defines which column in data will be used for the x-axis in the chart.
 - [Optional] The colors node contains a set of color nodes in type of ColorSetting that defines the colors to be used in the charts view control.

This ChartView node contains following attributes,
 - All the attributes defined in the ViewAttributes.
 - Plus following attributes,
*/
class ChartView : public ViewElements, public ViewAttributes
{
  public ChartType chartType;       //!< [Mandatory] Thia attribute controls which type of chart is to be rendered.
  public bool showLegend;           //!< [Optional] This attribute controls if the legend should be displayed together with the chart.
  public LineType lineType;         //!< [Optional] This attribute controls the line type to be used in the charts.
  public HtmlColor background;      //!< [Optional] This attribute controls the background color for the chart.
  public bool showTooltip;          //!< [Optional] This attribute controls if the tooltip should be visible in the chart.
};

//! \brief This FileList is a data view control that uses a list view to display files and/or folders under the specified path in file system.
/*!
The FileList implements most of the features available in the ListView, including filter, status, copy, etc. Please refer to ListView for more details on these features.

The FileList node contains following child nodes,
 - All the nodes defined in the ViewElements.
 - [Optional] The rowStyles node contains a set of row nodes in type of RowStyle that defines the style for matched rows.

The FileList node contains following attributes,
 - All the attributes defined in the ViewAttributes.
 - Plus following attributes,
*/
class FileList : public ViewElements, public ViewAttributes
{
  public bool multiSelect;      //!< [Optional] This attribute controls if the file list view supports multiple selections on the items. The default value is false.
  public bool filter;           //!< [Optional] This attribute controls if the filter support is enabled for the file list view. The default value is true.
  public bool status;           //!< [Optional] This attribute controls if the status bar is enabled for the file list view. The default value is true.
  public bool files;            //!< [Optiona;] This attribute controls if files are shown in the file list view. The default value is true.
  public bool dirs;             //!< [Optional] This attribute controls if folders are shown in the file list view, The default value is false;
  public bool hidden;           //!< [Optional] This attribute controls if hiden files/folders are shown in the file list view. The default value is false.
  public bool dotdot;           //!< [Optional] This attribute controls if . and .. folders are shown in the file list view. The default value is false.
};

//! \brief This FileTree is a data view control that uses a tree view to display the folder structures under the specified path in file system.
/*!
The FileTree implements similar features available in the TreeView. It loads the folder hierachy in file system and populate them into the tree view control. User may expand/collapse a folder or select a folder to trigger further actions in other controls.

The FileTree node contains following nodes,
 - All the nodes defined in the ViewElements.

The FileTree node contains following attribtues,
 - All the attributes defined in the ViewAttributes.
 - Plus following attributes,
*/
class FileTree : public ViewElements, public ViewAttributes
{
  public string root;       //!< [Optional] This attribute controls the default path that the FileTree will load data from. Empty value means that it will be loaded from the system root.
};

//! \brief This HexView control is a data view control that displays binary data in the hexadecimal format.
/*!
The HexView displays each byte in the binary data as two-digit hexadecimal. User may customize the control to display offset for each line and also show the text form for each byte if it's visual character, otherwise a dot '.' is displayed for the byte. Besides, user may customize how many bytes are displayed in each line and how many bytes should be grouped in each line. The byte count in line should be multiplies of byte count in each group.

The HexView node contains following nodes,
 - All the nodes defined in the ViewElements.
 - The font node in type of FontDesc that defines which font is used to display the content in the HexView.
 - The highlights node which contains a list of highlight nodes in type of HexViewHighlightSettings that defines the highlight styles to be used in the HexView control.

The HexView node contains following attributes,
 - All the attributes defined in the ViewAttributes.
 - Plus following attributes,
*/
class HexView : public ViewElements, public ViewAttributes
{
	public unsigned int groupSize;  //!< [Optional] This defines how many bytes are displayed in each group in a line. The default value is 0 which means the data is not grouped.
    public unsigned int lineSize;   //!< [Optional] This defines how many bytes are displayed in each line. The default value is 16.
	public unsigned int offsetSize; //!< [Optional] This defines how many digits are used to display the offset for the data. The default value is 8.
    public bool showOffset;         //!< [Optional] This boolean flag controls if the offset area is shown in the HexView control. The default value is true.
    public bool showText;           //!< [Optional] This boolean flag controls if the text form of the bytes is shown in the control. The default value is true.
};

//! \brief This ListView is a data view control that uses the commonly used list view control to display data in rows and columns.
/*!
Besides displaying data, this view control supports many other useful features,
 - Supports single selection or multiple selection of items in the list view.
 - The index of selected row as well as values in each of the columns in the selected row could be sent out to other view controls through output parameters for the ListView.
 - There is rich filtering feature supported in the ListView control, see details in the \ref section_smart_filter.
 - User may copy full row or selected columns from the selected row(s) into clipboard, in plain text or HTML format.
 - There is status bar showing the item status and selection status for the items in the ListView.

This ListView node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Optional] The filter node in type of ListViewFilter configures the filter setting for the ListView.
 - [Optional] The status node in type of ListViewStatus configures the status setting for the ListView.
 - [Mandatory] The columns node in type of ColumnSet defines the columns to be shown in the ListView control.
 - [Optional] The rowStyles node contains a set of row nodes in type of RowStyle that defines the style for matched rows.
 
This ListView node contains following attributes,
 - All the attributes defined in the ViewAttributes.
 - Plus following attributes,
*/
class ListView : public ViewElements, public ViewAttributes
{
  public bool sortable;         //!< [Optional] This boolean attribute controls if the ListView supports sorting by clicking on column headers.
  public bool multiSelect;      //!< [Optional] This boolean attribute controls if the ListView supports multiple selection of items.
};

//! \brief This TextView is a data view control for displaying single line or multiple lines of plain text.
/*!
This TextView node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Optional] The font node in type of FontDesc defines the font to be used for displaying the text content.
 - [Optional] The content node contains the predefined content to be displayed in the control.

This TextView node contains following attributes,
- All the attributes defined in the ViewAttributes.
- Plus following attributes,
*/
class TextView : public ViewElements, public ViewAttributes
{
  public bool noWrap;           //!< [Optional] This boolean attribute controls if the text content longer than the TextView client width should be wrapped automatically (when the value is false). The default value is false.
  public bool multiline;        //!< [Optional] This boolean attribute controls if the control can display multiple lines of text content. The default value is true.
  public bool readOnly;         //!< [Optional] This boolean attribute controls if the control is used to display text only. When this attribute is set to false, user may edit the content in place. The default value is false.
};

//! \brief This TreeListView is a data view control for displaying hierachy data in multiple columns.
/*!
This TreeListView control combines features from both list view and tree view. It can display the hierachy data as tree view, meanwhile it can also display data for each node with more details in multiple columns, like the list view.

This TreeListView node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Mandatory] The columns node in type of ColumnSet defines the columns to be shown in the TreeListView.
 - [Optional] The rowStyles node contains a set of row nodes in type of RowStyle that defines the style for matched rows.

This TreeListView node contains following attributes,
 - All the attributes defined in ViewAttributes.
 - Plus following attributes,
*/
class TreeListView : public ViewElements, public ViewAttributes
{
  public string childProperty;  //!< [Mandatory] This attribute define the property name for getting the child node data in the data for current node.
  public int expandLevel;       //!< [Optional] This attribute defines how many levels of child data will be expanded automatically when data is loaded into the control. Default value is 0.
};

//! \brief This TreeView is a data view control for displaying hierachy data in tree style.
/*!
This TreeView control requires data being presented in layers through a predefined child property. The value of the child property should be an array in the same type of data, each element in the array reprensents a child node of current node.

This TreeView node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Optional] The nodeColors node contains a set of node nodes in type of RowStyle that defines the style for matched nodes.

This TreeView node contains following attributes,
 - All the attributes defined in ViewAttributes.
 - Plus following attributes,
*/
class TreeView : public ViewElements, public ViewAttributes
{
  public string labelProperty;  //!< [Optional] This attribute defines the name of data property that contains the name value for tree node. The default value is name.
  public string childProperty;  //!< [Mandatory] This attribute defines the name of data property that contains data for the child nodes.
};

//! \brief This WebView is a data view control for displaying data through Web page form.
/*!
This WebView can be used to show data in any form that the user wants to, depends on how the page content is rendered. The LSB view creators can use HTML + JavaScript + CSS to create whatever they want to visualize the data. This provides LSB the capability to render data in forms not limited to the existing data view controls.

Basically the LSB view authors can create any new controls with the support of HTML + JavaScript in the WebView.

The WebView node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Optional] The styles node contains a set of file nodes in type of FileReference that define the CSS style files to be referenced in the WebView page.
 - [Optional] The scripts node contains a set of file nodes in type of FileReference that define the JavaScript files to be referenced in the WebView page.
 - [Optional] The body node in type of FileReference defines the web page body content defined in separate file.
 - [Optional] The highlights node contains a set of highlight nodes that define how specific content in the Web page content should be highlighted.

The WebView node contains following attributes,
 - All the attributes defined in ViewAttributes.
 - Plus following attributes,
*/
class WebView : public ViewElements, public ViewAttributes
{
  public ContentType contentType;    //!< [Mandatory] This attrubutes defines the type of the data that is returned from the data source associated with the WebView control.
  public bool selectToHighlight;     //!< [Optional] This attribute controls if the highlight for selection should be enabled or not. The default value is false.
};

//! \brief This Button is an input control for taking user's click action to confirm or trigger an operation.
/*!
The Button control uses the button control in GUI applications to implment the functionalities. It typically shows a string as label and has a piece of script hooked with it - when the end user clicks on the button, the corresponding scipt will be executed to take an action or grab data from various data sources. And the LSB view can in term pass the returned data to other controls to implement corresponding business logic.

The Button node contains following child nodes,
 - All the nodes defined in ViewElements.

The Button node contains following attributes,
 - All the attributes defined in ViewAttributes.
 - Plus following attributes,
*/
class Button : public ViewElements, public ViewAttributes
{
    public DockStyle dock;      //!< [Optional] This dock attribute controls how the button is arranged within the space allocated for it. See DockStyle for detailed explanations on each possible values. The default value is None.
	public string label;        //!< [Mandatory] This label attribute defines the text to be displayed on the button control.
    public string description;  //!< [Optional] The attribute defines the description text for the button, which is also used as the content for the hint for the button.
};

//! \brief The ComboBox is an input control that supports user to either select a value from a predefined value list or type in any other value.
/*!
The ComboBox control is a combination of a list box and an edit control. The end user may select a value from the predefined value list or type in a value through the edit control. And the control will send the value out through output parameter to trigger further action(s).

The ComboBox node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Optional] The prompt node in type of Prompt defines the prompt for the ComboBox input.
 - [Optional] The options node in type of OptionList defines the preset values that the end user can select one value from them.

The ComboBox node contains following attributes,
 - All the attributes defined in ViewAttributes.
 - Plus following attributes,
*/
class ComboBox : public ViewElements, public ViewAttributes
{
    public bool selectOnly;         //!< [Optional] This boolean flag controls if the ComboBox supports selecting value from list only (true) or also allows end user to type in value (false). The default value is false.
	public bool sorted;             //!< [Optional] This boolean flag controls if the values in the value list are sorted or not. The default value is false.
	public TrimSpace trimSpace;     //!< [Optional] This attribute controls if the user selected/typed in value should have space(s) trimmed before it's sent to other view controls. The default value is None.
    public string defaultValue;     //!< [Optional] This attribute defines the default value for the control. The default value is empty string.
};

//! \brief The TextInput is an input control that allows user to type in any character as the input value.
/*!
The TextInput supports both single line and multiple line text edit control that allows end user to type in text as value and send to other view controls through output parameter associated with it. It's typically used as input control for one single value. To create input for multiple values or a complicated data structure, please refer to the PropertyInput control. The value inputted through TextInput is a string. View author can convert the the string value into any other data types as they need in the script(s).

The TextInput node contains following child nodes,
 - All the nodes defined in ViewElements.
 - [Optional] The prompt node in type of Prompt defines the prompt for the TextInput control.
 - [Optional] The content node defines the string content as the initial value for the TextInput control.

The TextInput node contains following attributes,
 - All the attributes defined in ViewAttributes.
 - Plus following attributes,
*/
class TextInput : public ViewElements, public ViewAttributes
{
    public string defaultValue;         //!< [Optional] This attribute defines the default value for the TextInput control. The default value is empty string.
	public TrimSpace trimSpace;         //!< [Optional] This attribute controls if the user selected/typed in value should have space(s) trimmed before it's sent to other view controls. The default value is None.
	public bool multiline;              //!< [Optional] This boolean attribute controls if the TextInput supports single line edit control or multiple line edit control. The default value is false, which means it implements as single line edit control.
	public WhenToNotify whenToNotify;   //!< [Optional] This attribute in type of WhenToNotify defines when to trigger the output parameter to send out the new value to other controls when the end user types in to the control. The default value is Enter, which means when the Enter key is pressed in the TextInput, the new value is sent out.
};

//! \brief The PropertyInput is an input control that supports editing multiple variables or complicated structure(s) in one single control.
/*!
The PropertyInput allows user to input multiple values within one single control, and it also supports inputing values in different types directly (not like TextInput or ComboBox, they only accept string input, and the view author has to do the conversion from string to the target data type). These features greatly help the view author on reducing the effort on creating input controls and doing data conversions. The supported data types can be found in the explanation for PropertyValueType.

The PropertyInput node contains following nodes,
 - All the nodes defined in ViewElements.
 - [Mandatory] The properties node contains a list of property node in type of PropertyField which configures for each property field, which is equivalent to a variable or a field in a complicates structure.

The PropertyInput node contains following attributes,
 - All the attributes defined in ViewAttributes,
 - Plus following attributes,
*/
class PropertyInput : public ViewElements, public ViewAttributes
{
    public TrimSpace trimSpace;     //!< [Optional] This attribute controls if the string values user typed in should have space(s) trimmed before it's sent to other view controls. The default value is None.
};

//! \brief The Procedure node does what the name means, execute a piece of script like procedure or function in programming languages.
/*!
The Procedure is an invisible component. It doesn't like other data view, input or layout controls, that they will take some space in the GUI. This component takes no space on screen at all. The purpose of this component is to take input from other controls or components, runs the configured script to complete certain functionality or generate a new data set, and then in turn passes the data to one or more other controls.

The Procedure node contains following child nodes,
 - All the nodes defined in ComponentElements.

The Procedure node contains following attributes,
 - All the attributes defined in ComponentAttributes,
 - Plus following attributes,
*/
class Procedure : public ComponentElements, public ComponentAttributes
{
    public string name;             //!< [Optional] This attribute defines the name of the procedure.
	public ExecuteAt executeAt;     //!< [Optional] This attribute in type of ExecuteAt controls when the script should be triggered, it could be one shot only or repetitive.
	public string timerInterval;    //!< [Optional] The script execution interval when the executeAt is set to TimerTicking or TimerStartAndTicking.
};

//! \brief The ViewLauncher node is a component to launch another LSB view with parameters.
/*!
The ViewLauncher is another invisible component. It collects parameter values from current view, sends them as input parameter for the target view and launches the target view specified through the view configuration. In the configuration, to specify the target view to be launched, view author needs to specify both the repository name and the view name. The reason is that the view name is not unique from LSB perspective - views in different view repositories might have the same name.

The ViewLauncher node contains following child nodes,
 - All the nodes defined in the ComponentElements.
 - [Mandatory] The connection node in type of DataFlow defines how the parameters in current view will be passed into the target view as input parameters.

The ViewLauncher node contains following attributes,
 - All the attributes defined in the ComponentAttributes,
 - Plus following attributes,
*/
class ViewLauncher : public ComponentElements, public ComponentAttributes
{
    public string repository;       //!< [Mandatory] This attribute defines the repository name of the target view to be launched.
	public string view;             //!< [Mandatory] This attribute defines the name of the target view to be launched.
};

/*!
@}
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \brief LsbView is the unit that is supported in the LSB to implement different functionalities to meet various business requirements.
/*!
In each of the LSB view file, LsbView is the root node that defines all the controls to be used within the LSB view, together with the corresponding scripts (Lua, bash, PowerShell or any other user defined scripts) and parameter flows to implement the specific business logic to achieve the goal.

The LsbView node contains following nodes,
 - [Optional] The description node contains a long string that describes the purpose, usage or any other view related information.
 - [Mandatory] The version node in type of Version defines the version number of the view.
 - [Optional] The modules node contains a list of module nodes. Each of the node contains a string that defines the path to a module that is referenced in the view.
 - [Optional] The value of this os node should be values in type of OS and separated by semi-colon. The values indicate which Operatings Systems are supported by the LSB view. 
 - [Optional] This about node in type of About contains the definition of the about information of this LSB view.
 - [Mandatory] The view node in type of ChoiceOfView is the root node of all the view controls used in the LSB view. Typically it starts with one of the layout controls, SplitLayout, TabLayout and TableLayout.
 - [Optional] The procedures node contains a list of procedure nodes in type of Procedure which define the script procedures/functions.
 - [Optional] The launchers node contains a list of launcher nodes in type of ViewLauncher that are used to launch another LSB view from current LSB view.
 - [Optional] The dataFlow node in type of DataFlow defines how an output parameter in a source view control is connected with an input parameter in a target view control.

The LsbView node contains following attributes,
*/
class LsbView
{
	public string name;             //!< [Mandatory] This attribute contains the name of the LSB view.
	public string author;           //!< [Mandatory] This attribute contains the author information (full name or nick name).
	public DateTime createTime;     //!< [Mandatory] This attribute contains timestamp of when the LSB view was created.
	public DateTime lastChangeTime; //!< [Mandatory] This attribute contains timestamp of when the LSB view was last changed.
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_create_view How to Create a LSB View

## LSB view file

The LSB view files use `.lsbv` as the file extension. It's basically an XML file that contains a set of predefined XML nodes to implement GUI using LSB provided controls and implement business logic using embedded Lua scripts and other shell scripts. The predefined nodes can be found in the schema definition file [LsbViewSchema.xsd](https://github.com/xjluo-lsb/lsb.views/blob/main/LsbViewSchema.xsd). The schema file also comes in the views folder for the DefaultViews repository. Besides the view controls, this schema file has all enumeration types, data types and data structures defined to be used in the LSB views.

The recommended editor for composing LSB view file is the Microsoft [Visual Studio](https://visualstudio.microsoft.com/). With the provided schema file LsbViewSchema.xsd properly added into the LSB view file, the Visual Studio can provide rich hints on the potential node names, attribute names, even values when user updates the view file. This is the only editor that I'm aware of that comes with this feature, other editors (including Visual Studio Code) support syntax highlighting, but not hints in a way close to Visual Studio. If your favorite editor does support hinting on the XML node/attribute/value, that's great. If you editor does not support the schema based hinting, no worry, please read the type documents here along with this page, you will get the necessary information to create an LSB view file properly.

## Write an LSB view

The LSB view files all contain the same structure descibed below, the detailed schema introduction can be found at the LsbView page. Meanwhile, please refer to the sample views come in the DefaultViews view repository to understand the file format better.

Every LSB view file requires a root node named LsbView, which has attributes named name, author, createTime and lastChangeTime. The node contains following child nodes, some of them are mandatory and others are optional. The order of these nodes is not significant.
- **description** is a node contains long description for the LSB view.
- **version** is a node describing the version of the LSB view.
- **modules** contains a list of modules that are automatically referenced in the Lua shell for the LSB view.
- **os** defines which Operating Systems are supported by this LSB view.
- **about** defines the about information for the view.
- **view** is the actual root view control for the LSB view. In most cases, this should be a layout control, such as SplitLayout, TabLayout, etc., which could contain multiple child views for input or data view, or another layout control to create more complicated UI and host more child views.
- **procedures** contains a list of procedures that provides separated shell scripts for various functionalitues if the LSB view needs them.
- **launchers** contains a list of launchers that are used to launch another LSB view from current view.
- **dataFlow** is the node that defines all the input parameter and output parameter mappings to get the view controls connected with operations.

Here's a sample view that hosts a simple text view for editing plain text,

\code{.xml}

<?xml version="1.0"?>

<LsbView xmlns="https://github.com/xjluo-lsb/lsb.views"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://github.com/xjluo-lsb/lsb.views ..\LsbViewSchema.xsd"
         
  name="TextView demo"
  author="Kevin Luo"
  createTime="2024-10-24T00:00:00Z"
  lastChangeTime="2024-10-24T00:00:00.000Z">

  <description>A simplest view that demonstrates the TextView control.</description>
  <version major="0" minor="1" build="0" revision="0" />

  <view>
    <textView id="6d627fac-651b-4815-b0fa-4d584f0bc45e" multiline="false" readOnly="false">
      <data showProgress="false">
        <script type="lua">
<![CDATA[
return [[This is the default text for the view.]]
]]>
        </script>
      </data>
    </textView>
  </view>
</LsbView>

\endcode

You may save this code snipper into an lsbv file, put it into your own load view repository and then open it in the LSB application, the UI will look like the screenshot below,

**TODO: update the screenshot for the sample view**

In the textView control, you may type in more text, modify or delete the existing default text "This is the default text for the view.", because the textView control has the readOnly attribute set to false.

## Parameter mapping

The previous example simply shows one single text view control and does not need to send any values with any other view controls, thus it didn't show the use of the **dataFlow** node. Here we are going to use a more complicated view as example to explain the usage of the **dataFlow** node. Read the code below and save the code snippet into a new lsbv file in your test repository.

\code{.xml}

<?xml version="1.0"?>
 
<LsbView xmlns="https://github.com/xjluo-lsb/lsb.views"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://github.com/xjluo-lsb/lsb.views ..\LsbViewSchema.xsd"
         
  name="Parameter demo"
  author="Kevin Luo"
  createTime="2025-03-14T00:00:00Z"
  lastChangeTime="2023-03-14T00:00:00.000Z">
 
  <description>A sample view that demonstrates how to send parameters from one view control to another.</description>
  <version major="0" minor="1" build="0" revision="0" />
 
  <view>
    <!-- The split layout put the two child views side by side, one in left and one in right, and the left list view has fixed size -->
    <splitLayout id="ea0f1237-2d35-460d-b5c0-108c5d4a8dcd" orientation="Horizontal" fixedView="Left" size="320">
      <left>
        <!-- Please be noted that we set the loadDataAt to Creating so the Lua script will be executed at the list view creating time,
             and the data will also be loaded into the list view at the creating time -->
        <listView id="0c96fd3d-36a4-4b6c-a04f-5094eeb8c619" loadDataAt="Creating">
          <caption visible="true">Web site list</caption>
          <input />
          <output>
            <!-- We are going to send out the value in the Name column when a row is selected in the list view -->
            <param id="96e9164c-867e-4ca5-9bd1-ddaa2ec4b175" name="Name" />
            <!-- We are going to send out the value in the URL column when a row is selected in the list view -->
            <param id="8e9d8168-86f4-47df-9a5d-f9b9190d1aaf" name="URL" />
          </output>
          <data showProgress="false">
            <!-- We use Lua script below to build an array that contains a list objects for the data, with Name attribute for the Web
                 site name and URL attribute for the Web site URL. -->
            <script type="Lua">
<![CDATA[
return {
  { Name = "Bing", URL = "https://www.bing.com" },
  { Name = "Google", URL = "https://www.google.com" },
  { Name = "OpenAI", URL = "https://chat.openai.com" }
}
]]>
            </script>
          </data>
          <columns>
            <column name="Name" width="80" />
            <column name="URL" width="200" />
          </columns>
        </listView>
      </left>
      <right>
        <!-- Here we configure the WebView to use the data returned from Lua script as page URL through the contentType attribute -->
        <webView id="57caee6b-80d0-482e-982c-f4faf8361f82" contentType="Url">
          <caption visible="true">Visiting {Name} ...</caption>
          <input>
            <!-- The WebView takes the Name input parameter and uses it in the caption -->
            <param id="e5fc9d94-636b-42b8-8b74-457beefacd7c" name="Name" />
            <!-- The WebView takes the URL input parameter and uses it in the Lua script -->
            <param id="343cc934-2122-4d42-8689-369a733c4032" name="URL" />
          </input>
          <data showProgress="false">
            <!-- The Lua script simply returns the URL passed in and WebView will automatically navigate to the returned URL. -->
            <script type="Lua">
<![CDATA[return "{URL}"]]>
            </script>
          </data>
        </webView>
      </right>
    </splitLayout>
  </view>
 
  <dataFlow>
    <!-- Send the Web site name from the ListView to the WebView -->
    <mapping source="96e9164c-867e-4ca5-9bd1-ddaa2ec4b175">
      <target>e5fc9d94-636b-42b8-8b74-457beefacd7c</target>
    </mapping>
    <!-- Send the Web site URL from the ListView to the WebView -->
    <mapping source="8e9d8168-86f4-47df-9a5d-f9b9190d1aaf">
      <target>343cc934-2122-4d42-8689-369a733c4032</target>
    </mapping>
  </dataFlow>
</LsbView>

\endcode

After you open the view in the LSB application, it should look like screenshot below,

**TODO: screenshot for sample view**

When you click on a Web site in the list view, the Web view will have the page loaded and the caption updated simultaneously. Meanwhile, you will see following messages in the **Logs** page,

**TODO: screenshot for message logs**

Now let's look back at the **dataFlow** section in the LSB view file, it would become easy to understand,
<ul>
<li>The parameter with ID `96e9164c-867e-4ca5-9bd1-ddaa2ec4b175` is the output parameter from the list view for the Web site name, and it associated with the input parameter with ID `e5fc9d94-636b-42b8-8b74-457beefacd7c` on the Web View. This is defined in the first mapping in the **dataFlow** section. In the screenshot, value "" was sent out from the list view and passed into the web view for updating the caption.</li>
<li>The parameter with ID `8e9d8168-86f4-47df-9a5d-f9b9190d1aaf` is the output parameter from the list view for the Web site URL, and it's associated with the input parameter with ID `343cc934-2122-4d42-8689-369a733c4032` on the Web view. This is defined in the second mapping in the **dataFlow** section. In the screenshot, value "" was sent out from the list view and passed into the web view for loading page content from the URL.</li>
</ul>

*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_debug_view How to Test / Debug an LSB View

## Testing an LSB view

An LSB view should be tested before it's released to other users. The LSB application provides multiple features that can help the view creators to test and debug the LSB views, such as local view repository, message logging, etc. Here are the steps on how a view creator can test an LSB view locally through the LSB application.

<ol>
<li>If you haven't had a local view repository created for testing views, then follow the steps below. Otherwise go directly to step 2.
  <ul>
    <li>Create a folder locally for all the views to be created/tested.</li>
    <li>Launch the LSB application and open the settings dialog, create a new view repository points to this folder.</li>
    <li>No remote GIT URL is needed, this makes it a local view repository. Please be sure to have it enabled so the views in this repository will show up in the **"Open a view"** dialog.</li>
  </ul>
</li>
<li>Create or put the LSB view to be tested in this local view repository folder.</li>
<li>Open the view to be tested in the LSB application, now you can see the view content.</li>
<li>In the **Logs** page in the view window, you can find how the parameters are populated and how parameters are passed between different view controls in the LSB view.</li>
<li>In the Lua tab in the view window, you can find all the Lua scripts executed within the view to implement the functionalities, such as parameter check, data generation, etc.</li>
<li>If there are other shell scripts used in the LSB view, there should be more pages available in the LSB view window, each for a different shell type. All the executed shell scripts and the result output to console will all show up there.</li>
</ol>

One of the most typical issues is that one user action on the UI doesn't trigger the next step operation. For example, in the previous Parameter Demo sample view, when user select a Web site row in the list view, it didn't trigger the refresh in the Web view. When this happens, there are a few things to check,
<ul>
  <li>Is the output parameter value sent out? If the output parameter name in the list view control is different from the column name or attribute name in data, then there won't be any output parameter message. This could be verified in the parameter change list in the **Logs** page.</li>
  <li>Is the parameter mapping set correctly? If the output parameter has sent out the new value, the next step is to check if the corresponding input parameter in the other control received this change. If there is no event logged in the parameter change list in the **Logs** page, then please check if the parameter mapping was configured properly.</li>
  <li>If it's confirmed that the input parameter received the value change, but the UI still doesn't respond correctly. The next thing to check is the parameter condition for the view control. The condition test result should be logged in the message list. If input parameter changes are detected but the values do not match the condition, the content would not be refreshed.</li>
</ul>

## Module References

Even though the LSB view provides the **Lua** page and other shell pages to show the embedded Lua scripts and shell scripts executed in the LSB view, are difficult to debug directly inside the LSB view. The recommended way for writing embbeded scripts is to write large pieces of scripts in separated script files and add them through the module references. By putting the scripts into dedicated files, it's relative easier to use the tools come with the script language to test and debug. After the script files are tested, the scripts embedded in the LSB view only makes simple calls to the functions defined in the script files.

*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
\defgroup section_faq Frequently Asked Questions

<ul>
<li>**How to configure the default view repository?**<br/>
The default view repository comes with the application and uses **DefaultViews** as the repository name. It's not configurable through the **Settings** dialog.</li>
<li>**Can I open multiple view instances for the same LSB view?**<br/>
Yes, you can open the same LSB view as many times as you want. Each instance of the same LSB view will have its own window. The different LSB view instances do not share any data in between for safety reason.</li>
<li>**How many LSB views can I open with the LSB application?**<br/>
There is no limitation on how many LSB view instances you can open, as long as the computer's memory allows it.</li>
</ul>

*/

